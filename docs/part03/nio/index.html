<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- 기본 메타데이터 --><meta name="description" content="Jiny linux"><meta name="author" content="HojinLee"><!-- 제목 설정 --><title>25. NIO 기반 입출력 및 네트워킹</title>
  <meta name="title" content="25. NIO 기반 입출력 및 네트워킹" /><!-- 키워드 설정 --><!-- Open Graph 메타데이터 --><meta property="og:title" content="25. NIO 기반 입출력 및 네트워킹"><meta property="og:description" content="Jiny linux"><meta property="og:type" content="website"><meta property="og:locale" content="ko">
  <meta property="og:site_name" content="linux">
  <meta property="og:url" content="https://java.jiny.dev/part03/nio/">

  <!-- Twitter 카드 메타데이터 --><meta name="twitter:card" content="summary"><meta property="twitter:title" content="25. NIO 기반 입출력 및 네트워킹"><!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="NIO 기반 입출력 및 네트워킹" />
<meta name="author" content="Hojin" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="자바 언어를 통한 객체지향 프로그래밍의 이해와 실습" />
<meta property="og:description" content="자바 언어를 통한 객체지향 프로그래밍의 이해와 실습" />
<link rel="canonical" href="https://java.jiny.dev/part03/nio/" />
<meta property="og:url" content="https://java.jiny.dev/part03/nio/" />
<meta property="og:site_name" content="객체지향 자바 프로그래밍 (Object-Oriented Java Programming)" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="NIO 기반 입출력 및 네트워킹" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"Hojin"},"description":"자바 언어를 통한 객체지향 프로그래밍의 이해와 실습","headline":"NIO 기반 입출력 및 네트워킹","url":"https://java.jiny.dev/part03/nio/"}</script>
<!-- End Jekyll SEO tag -->


  <link href="/assets/css/bootstrap.min.css" rel="stylesheet" />
  <link href="/assets/css/docs.css" rel="stylesheet" />
  <link href="/assets/css/highlight.css" rel="stylesheet" />

  <style>
    blockquote {
      border-left: solid 5px #dee2e6;
      padding: 5px 10px;
      background-color: #f8f9fa;
    }
  </style>

  <style>
    h1 a {
      text-decoration: none;
    }

    h2 a {
      text-decoration: none;
    }

    h3 a {
      text-decoration: none;
    }

    h4 a {
      text-decoration: none;
    }

    h5 a {
      text-decoration: none;
    }

    h6 a {
      text-decoration: none;
    }

    img {
      max-width: 100%;
      height: auto;
      vertical-align: top
    }

    strong a {
      text-decoration: none;
      color: inherit;
    }

    /* 스크롤바 커스텀 */
    /* 임의의 영역 생성 */
    .scrollBar {}

    /* 아래의 모든 코드는 영역::코드로 사용 */
    .scrollBar::-webkit-scrollbar {
      width: 7px;
      /* 스크롤바의 너비 */
    }

    .scrollBar::-webkit-scrollbar-thumb {
      height: 30%;
      /* 스크롤바의 길이 */
      background: #cccccc;
      /* 스크롤바의 색상 */

      border-radius: 5px;
    }

    .scrollBar::-webkit-scrollbar-track {
      background: rgba(33, 122, 244, .1);
      /*스크롤바 뒷 배경 색상*/
    }
  </style>

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-R4VBPCT3CR"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-R4VBPCT3CR');
  </script>


</head>

<body>
  <header class="navbar navbar-expand-lg bd-navbar sticky-top">
    <nav class="container bd-gutter flex-wrap flex-lg-nowrap position-relative" aria-label="Main navigation">

      <!-- Mobile: Left Toggle (Browse) -->
      <div class="bd-navbar-toggle d-lg-none">
        <button class="navbar-toggler p-2" type="button" data-bs-toggle="offcanvas" data-bs-target="#bdSidebar"
          aria-controls="bdSidebar" aria-label="Toggle docs navigation">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" class="bi" fill="currentColor"
            viewBox="0 0 16 16">
            <path fill-rule="evenodd"
              d="M2.5 11.5A.5.5 0 0 1 3 11h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4A.5.5 0 0 1 3 7h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4A.5.5 0 0 1 3 3h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z">
            </path>
          </svg>
          <span class="d-none fs-6 pe-1">Browse</span>
        </button>
      </div>

      <!-- Brand: Desktop (Static), Mobile (Absolute Center) -->
      <a class="navbar-brand p-0 me-0 me-lg-2 ms-lg-0 d-none d-lg-inline-block" href="/" aria-label="jinydev">
        <svg width="32" height="26" viewBox="0 0 32 29" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M24.2746 5.33377C25.8486 7.33981 25.1183 11.1792 24.3961 13.0177C24.4028 13.0199 24.4094 13.0221 24.4161 13.0243L24.4013 13.0248L22.649 12.9082C22.649 12.9053 22.6488 12.9013 22.649 12.8993C22.9902 8.93373 22.5975 7.34575 22.2147 7.07677C17.6316 10.3896 13.5379 9.33658 12.2725 9.01111C11.928 8.9225 11.7932 8.88781 11.9152 9.00988C12.2872 9.38185 13.1336 9.82821 13.7371 10.1465H13.7372L13.7376 10.1467C13.8743 10.2188 13.9985 10.2843 14.1019 10.3409C9.12673 10.3984 7.12659 8.00279 6.53855 7.29846C6.47859 7.22664 6.4333 7.1724 6.40105 7.14015C6.11408 6.85318 4.49961 5.87252 3.99256 7.74227C3.50142 9.55335 3.81246 11.6775 3.97665 12.7988C3.99089 12.896 3.99257 12.8981 3.99257 12.9298L2.37635 13.0248L2.37213 13.0247C0.223493 8.05534 1.83854 5.26971 3.29536 4.2246C3.29536 1.78444 6.27428 -0.592359 10.0455 0.263262C14.8768 1.64043 16.3468 1.18409 18.0759 0.647278C18.774 0.430562 19.5143 0.200726 20.5351 0.073124C25.2219 -0.512739 26.7993 2.56612 27 4.16122C26.2141 3.70487 24.8556 4.73165 24.2746 5.33377ZM12.3374 1.5872C11.1225 1.16466 7.99257 0.717209 6.3478 2.41116C5.98397 2.78587 5.55554 3.48864 5.55554 3.48864C5.55554 3.48864 4.82665 4.81961 4.25622 4.24919C3.68579 3.67878 5.0168 1.96749 6.06259 1.46044C7.10838 0.953388 9.70703 0.0660505 12.3374 1.5872Z"
            fill="currentColor" />
          <path
            d="M10.078 13.5002H3.10601C2.2309 13.5002 1.52148 14.2097 1.52148 15.0848V18.3172C1.52148 19.1923 2.2309 19.9018 3.10601 19.9018H10.078C10.9531 19.9018 11.6625 19.1923 11.6625 18.3172V15.0848C11.6625 14.2097 10.9531 13.5002 10.078 13.5002Z"
            stroke="currentColor" stroke-width="1.26763" />
          <path
            d="M0.823513 14.6094H0.379847C0.187322 14.6094 0.03125 14.7654 0.03125 14.958V15.9721C0.03125 16.1646 0.187322 16.3207 0.379847 16.3207H0.823513C1.01604 16.3207 1.17211 16.1646 1.17211 15.9721V14.958C1.17211 14.7654 1.01604 14.6094 0.823513 14.6094Z"
            fill="currentColor" stroke="currentColor" stroke-width="0.0633813" />
          <path
            d="M16.7326 13.5002H23.7045C24.5796 13.5002 25.2891 14.2097 25.2891 15.0848V18.3172C25.2891 19.1923 24.5796 19.9018 23.7045 19.9018H16.7326C15.8575 19.9018 15.1481 19.1923 15.1481 18.3172V15.0848C15.1481 14.2097 15.8575 13.5002 16.7326 13.5002Z"
            stroke="currentColor" stroke-width="1.26763" />
          <path
            d="M25.9861 14.6094H26.4297C26.6222 14.6094 26.7783 14.7654 26.7783 14.958V15.9721C26.7783 16.1646 26.6222 16.3207 26.4297 16.3207H25.9861C25.7935 16.3207 25.6375 16.1646 25.6375 15.9721V14.958C25.6375 14.7654 25.7935 14.6094 25.9861 14.6094Z"
            fill="currentColor" stroke="currentColor" stroke-width="0.0633813" />
          <path
            d="M12.2954 15.5601H14.5137C14.7062 15.5601 14.8623 15.7161 14.8623 15.9087V16.9228C14.8623 17.1153 14.7062 17.2713 14.5137 17.2713H12.2954C12.1028 17.2713 11.9468 17.1153 11.9468 16.9228V15.9087C11.9468 15.7161 12.1028 15.5601 12.2954 15.5601Z"
            fill="currentColor" stroke="currentColor" stroke-width="0.0633813" />
          <path
            d="M9.93343 16.3937C9.93343 16.7087 9.76317 16.9641 9.55314 16.9641C9.34311 16.9641 9.17285 16.7087 9.17285 16.3937C9.17285 16.0786 9.34311 15.8232 9.55314 15.8232C9.76317 15.8232 9.93343 16.0786 9.93343 16.3937Z"
            fill="currentColor" />
          <path
            d="M16.9688 16.3937C16.9688 16.7087 17.139 16.9641 17.3491 16.9641C17.5591 16.9641 17.7293 16.7087 17.7293 16.3937C17.7293 16.0786 17.5591 15.8232 17.3491 15.8232C17.139 15.8232 16.9688 16.0786 16.9688 16.3937Z"
            fill="currentColor" />
          <path
            d="M14.2758 20.1016C13.642 20.6086 12.7863 20.3551 12.5645 20.1016C12.6278 20.4185 12.8687 20.8622 13.4518 20.8622C14.0349 20.8622 14.2441 20.3551 14.2758 20.1016Z"
            fill="currentColor" />
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M12.1312 22.411C12.1575 22.2914 12.2759 22.2157 12.3956 22.2421L14.6347 22.735C14.7544 22.7614 14.83 22.8797 14.8036 22.9994C14.7773 23.119 14.659 23.1947 14.5393 23.1683L12.3002 22.6753C12.1805 22.649 12.1049 22.5307 12.1312 22.411Z"
            fill="currentColor" />
          <path
            d="M13.4203 27.6754C9.00897 27.7261 5.77228 23.6613 4.70536 21.6225C4.54691 21.3197 4.42016 21.2739 4.32509 21.3373C4.17297 21.4387 4.28282 21.6437 4.32507 21.7493C4.85747 22.9916 5.58213 24.0416 5.87791 24.4113C4.83846 26.1353 4.49409 27.855 4.45183 28.4994C6.1758 26.8008 7.91668 26.8832 8.57162 27.1367C13.7055 29.7987 16.5577 27.929 18.1739 27.1367C19.4669 26.5029 21.4803 27.7388 22.3254 28.436C22.224 26.8642 21.3747 25.1402 20.9627 24.4747C21.6282 23.5873 22.1669 22.5099 22.4522 21.9711C22.6803 21.5401 22.6106 21.369 22.5472 21.3373C22.3951 21.2613 22.2092 21.4958 22.1353 21.6225C21.6599 22.4148 18.9345 27.6121 13.4203 27.6754Z"
            fill="currentColor" />
        </svg>
      </a>
      <a class="navbar-brand p-0 me-0 position-absolute top-50 start-50 translate-middle d-lg-none" href="/"
        aria-label="jinydev">
        <svg width="100" height="26" viewBox="0 0 112 29" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M24.2746 5.33377C25.8486 7.33981 25.1183 11.1792 24.3961 13.0177C24.4028 13.0199 24.4094 13.0221 24.4161 13.0243L24.4013 13.0248L22.649 12.9082C22.649 12.9053 22.6488 12.9013 22.649 12.8993C22.9902 8.93373 22.5975 7.34575 22.2147 7.07677C17.6316 10.3896 13.5379 9.33658 12.2725 9.01111C11.928 8.9225 11.7932 8.88781 11.9152 9.00988C12.2872 9.38185 13.1336 9.82821 13.7371 10.1465H13.7372L13.7376 10.1467C13.8743 10.2188 13.9985 10.2843 14.1019 10.3409C9.12673 10.3984 7.12659 8.00279 6.53855 7.29846C6.47859 7.22664 6.4333 7.1724 6.40105 7.14015C6.11408 6.85318 4.49961 5.87252 3.99256 7.74227C3.50142 9.55335 3.81246 11.6775 3.97665 12.7988C3.99089 12.896 3.99257 12.8981 3.99257 12.9298L2.37635 13.0248L2.37213 13.0247C0.223493 8.05534 1.83854 5.26971 3.29536 4.2246C3.29536 1.78444 6.27428 -0.592359 10.0455 0.263262C14.8768 1.64043 16.3468 1.18409 18.0759 0.647278C18.774 0.430562 19.5143 0.200726 20.5351 0.073124C25.2219 -0.512739 26.7993 2.56612 27 4.16122C26.2141 3.70487 24.8556 4.73165 24.2746 5.33377ZM12.3374 1.5872C11.1225 1.16466 7.99257 0.717209 6.3478 2.41116C5.98397 2.78587 5.55554 3.48864 5.55554 3.48864C5.55554 3.48864 4.82665 4.81961 4.25622 4.24919C3.68579 3.67878 5.0168 1.96749 6.06259 1.46044C7.10838 0.953388 9.70703 0.0660505 12.3374 1.5872Z"
            fill="currentColor" />
          <path
            d="M10.078 13.5002H3.10601C2.2309 13.5002 1.52148 14.2097 1.52148 15.0848V18.3172C1.52148 19.1923 2.2309 19.9018 3.10601 19.9018H10.078C10.9531 19.9018 11.6625 19.1923 11.6625 18.3172V15.0848C11.6625 14.2097 10.9531 13.5002 10.078 13.5002Z"
            stroke="currentColor" stroke-width="1.26763" />
          <path
            d="M0.823513 14.6094H0.379847C0.187322 14.6094 0.03125 14.7654 0.03125 14.958V15.9721C0.03125 16.1646 0.187322 16.3207 0.379847 16.3207H0.823513C1.01604 16.3207 1.17211 16.1646 1.17211 15.9721V14.958C1.17211 14.7654 1.01604 14.6094 0.823513 14.6094Z"
            fill="currentColor" stroke="currentColor" stroke-width="0.0633813" />
          <path
            d="M16.7326 13.5002H23.7045C24.5796 13.5002 25.2891 14.2097 25.2891 15.0848V18.3172C25.2891 19.1923 24.5796 19.9018 23.7045 19.9018H16.7326C15.8575 19.9018 15.1481 19.1923 15.1481 18.3172V15.0848C15.1481 14.2097 15.8575 13.5002 16.7326 13.5002Z"
            stroke="currentColor" stroke-width="1.26763" />
          <path
            d="M25.9861 14.6094H26.4297C26.6222 14.6094 26.7783 14.7654 26.7783 14.958V15.9721C26.7783 16.1646 26.6222 16.3207 26.4297 16.3207H25.9861C25.7935 16.3207 25.6375 16.1646 25.6375 15.9721V14.958C25.6375 14.7654 25.7935 14.6094 25.9861 14.6094Z"
            fill="currentColor" stroke="currentColor" stroke-width="0.0633813" />
          <path
            d="M12.2954 15.5601H14.5137C14.7062 15.5601 14.8623 15.7161 14.8623 15.9087V16.9228C14.8623 17.1153 14.7062 17.2713 14.5137 17.2713H12.2954C12.1028 17.2713 11.9468 17.1153 11.9468 16.9228V15.9087C11.9468 15.7161 12.1028 15.5601 12.2954 15.5601Z"
            fill="currentColor" stroke="currentColor" stroke-width="0.0633813" />
          <path
            d="M9.93343 16.3937C9.93343 16.7087 9.76317 16.9641 9.55314 16.9641C9.34311 16.9641 9.17285 16.7087 9.17285 16.3937C9.17285 16.0786 9.34311 15.8232 9.55314 15.8232C9.76317 15.8232 9.93343 16.0786 9.93343 16.3937Z"
            fill="currentColor" />
          <path
            d="M16.9688 16.3937C16.9688 16.7087 17.139 16.9641 17.3491 16.9641C17.5591 16.9641 17.7293 16.7087 17.7293 16.3937C17.7293 16.0786 17.5591 15.8232 17.3491 15.8232C17.139 15.8232 16.9688 16.0786 16.9688 16.3937Z"
            fill="currentColor" />
          <path
            d="M14.2758 20.1016C13.642 20.6086 12.7863 20.3551 12.5645 20.1016C12.6278 20.4185 12.8687 20.8622 13.4518 20.8622C14.0349 20.8622 14.2441 20.3551 14.2758 20.1016Z"
            fill="currentColor" />
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M12.1312 22.411C12.1575 22.2914 12.2759 22.2157 12.3956 22.2421L14.6347 22.735C14.7544 22.7614 14.83 22.8797 14.8036 22.9994C14.7773 23.119 14.659 23.1947 14.5393 23.1683L12.3002 22.6753C12.1805 22.649 12.1049 22.5307 12.1312 22.411Z"
            fill="currentColor" />
          <path
            d="M13.4203 27.6754C9.00897 27.7261 5.77228 23.6613 4.70536 21.6225C4.54691 21.3197 4.42016 21.2739 4.32509 21.3373C4.17297 21.4387 4.28282 21.6437 4.32507 21.7493C4.85747 22.9916 5.58213 24.0416 5.87791 24.4113C4.83846 26.1353 4.49409 27.855 4.45183 28.4994C6.1758 26.8008 7.91668 26.8832 8.57162 27.1367C13.7055 29.7987 16.5577 27.929 18.1739 27.1367C19.4669 26.5029 21.4803 27.7388 22.3254 28.436C22.224 26.8642 21.3747 25.1402 20.9627 24.4747C21.6282 23.5873 22.1669 22.5099 22.4522 21.9711C22.6803 21.5401 22.6106 21.369 22.5472 21.3373C22.3951 21.2613 22.2092 21.4958 22.1353 21.6225C21.6599 22.4148 18.9345 27.6121 13.4203 27.6754Z"
            fill="currentColor" />
          <text x="32" y="21" font-family="Arial, sans-serif" font-weight="bold" font-size="22"
            fill="currentColor">Jiny</text>
        </svg>
      </a>

      <!-- Mobile: Right Toggle (Menu) -->
      <div class="d-flex d-lg-none ms-auto">
        <button class="navbar-toggler p-2" type="button" data-bs-toggle="offcanvas" data-bs-target="#bdNavbar"
          aria-controls="bdNavbar" aria-label="Toggle navigation">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grid"
            viewBox="0 0 16 16">
            <path
              d="M1 2.5A1.5 1.5 0 0 1 2.5 1h3A1.5 1.5 0 0 1 7 2.5v3A1.5 1.5 0 0 1 5.5 7h-3A1.5 1.5 0 0 1 1 5.5v-3zM2.5 2a.5.5 0 0 0-.5.5v3a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5v-3a.5.5 0 0 0-.5-.5h-3zm6.5.5A1.5 1.5 0 0 1 10.5 1h3A1.5 1.5 0 0 1 15 2.5v3A1.5 1.5 0 0 1 13.5 7h-3A1.5 1.5 0 0 1 9 5.5v-3zm1.5-.5a.5.5 0 0 0-.5.5v3a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5v-3a.5.5 0 0 0-.5-.5h-3zM1 10.5A1.5 1.5 0 0 1 2.5 9h3A1.5 1.5 0 0 1 7 10.5v3A1.5 1.5 0 0 1 5.5 15h-3A1.5 1.5 0 0 1 1 13.5v-3zm1.5-.5a.5.5 0 0 0-.5.5v3a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5v-3a.5.5 0 0 0-.5-.5h-3zm6.5.5A1.5 1.5 0 0 1 10.5 9h3a1.5 1.5 0 0 1 1.5 1.5v3a1.5 1.5 0 0 1-1.5 1.5h-3A1.5 1.5 0 0 1 9 13.5v-3zm1.5-.5a.5.5 0 0 0-.5.5v3a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5v-3a.5.5 0 0 0-.5-.5h-3z" />
          </svg>
        </button>
      </div>

      <!-- OffCanvas -->
      <div class="offcanvas-lg offcanvas-end flex-grow-1" tabindex="-1" id="bdNavbar"
        aria-labelledby="bdNavbarOffcanvasLabel" data-bs-scroll="true">
        <!-- OffCanver Header -->
        <div class="offcanvas-header px-4 pb-0">
          <h5 class="offcanvas-title text-white" id="bdNavbarOffcanvasLabel">Jiny</h5>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="offcanvas" aria-label="Close"
            data-bs-target="#bdNavbar">
          </button>
        </div>

        <!-- OffCanver Body -->
        <div class="offcanvas-body p-4 pt-0 p-lg-0">
          <hr class="d-lg-none text-white-50">

          <ul class="navbar-nav flex-column flex-lg-row bd-navbar-nav">
            
            <li class="nav-item">
              <a class="nav-link py-2 px-0 px-lg-2" href="/basic">자바기초</a>
            </li>
            
            <li class="nav-item">
              <a class="nav-link py-2 px-0 px-lg-2" href="/oop">객체지향</a>
            </li>
            
            <li class="nav-item">
              <a class="nav-link py-2 px-0 px-lg-2" href="/part03">입출력</a>
            </li>
            
            <li class="nav-item">
              <a class="nav-link py-2 px-0 px-lg-2" href="/database">데이터베이스</a>
            </li>
            
            <li class="nav-item">
              <a class="nav-link py-2 px-0 px-lg-2" href="/gui">GUI</a>
            </li>
            
            <li class="nav-item">
              <a class="nav-link py-2 px-0 px-lg-2" href="/backend">백엔드</a>
            </li>
            
          </ul>

          <hr class="d-lg-none text-white-50">

          <ul class="navbar-nav flex-row flex-wrap ms-md-auto">
            <li class="nav-item col-6 col-lg-auto">
              <a class="nav-link py-2 px-0 px-lg-2" href="https://github.com/jinydev/datas" target="_blank"
                rel="noopener">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" class="navbar-nav-svg"
                  viewBox="0 0 512 499.36" role="img">
                  <title>GitHub</title>
                  <path fill="currentColor" fill-rule="evenodd"
                    d="M256 0C114.64 0 0 114.61 0 256c0 113.09 73.34 209 175.08 242.9 12.8 2.35 17.47-5.56 17.47-12.34 0-6.08-.22-22.18-.35-43.54-71.2 15.49-86.2-34.34-86.2-34.34-11.64-29.57-28.42-37.45-28.42-37.45-23.27-15.84 1.73-15.55 1.73-15.55 25.69 1.81 39.21 26.38 39.21 26.38 22.84 39.12 59.92 27.82 74.5 21.27 2.33-16.54 8.94-27.82 16.25-34.22-56.84-6.43-116.6-28.43-116.6-126.49 0-27.95 10-50.8 26.35-68.69-2.63-6.48-11.42-32.5 2.51-67.75 0 0 21.49-6.88 70.4 26.24a242.65 242.65 0 0 1 128.18 0c48.87-33.13 70.33-26.24 70.33-26.24 14 35.25 5.18 61.27 2.55 67.75 16.41 17.9 26.31 40.75 26.31 68.69 0 98.35-59.85 120-116.88 126.32 9.19 7.9 17.38 23.53 17.38 47.41 0 34.22-.31 61.83-.31 70.23 0 6.85 4.61 14.81 17.6 12.31C438.72 464.97 512 369.08 512 256.02 512 114.62 397.37 0 256 0z">
                  </path>
                </svg>
                <small class="d-lg-none ms-2">GitHub</small>
              </a>
            </li>

            <li class="nav-item py-2 py-lg-1 col-12 col-lg-auto">
              <div class="vr d-none d-lg-flex h-100 mx-lg-2 text-white"></div>
              <hr class="d-lg-none my-2 text-white-50">
            </li>

            <li class="nav-item col-6 col-lg-auto">
              <a class="nav-link py-2 px-0 px-lg-2" href="https://jiny.dev" aria-label="Home">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" class="navbar-nav-svg"
                  viewBox="0 0 16 16" role="img">
                  <title>Home</title>
                  <path fill="currentColor"
                    d="M8.354 1.146a.5.5 0 0 0-.708 0l-6 6A.5.5 0 0 0 1.5 7.5v7a.5.5 0 0 0 .5.5h4.5a.5.5 0 0 0 .5-.5v-4h2v4a.5.5 0 0 0 .5.5H14a.5.5 0 0 0 .5-.5v-7a.5.5 0 0 0-.146-.354L13 5.793V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1.293L8.354 1.146zM2.5 14V7.707l5.5-5.5 5.5 5.5V14H10v-4a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5v4H2.5z" />
                </svg>
                <small class="d-lg-none ms-2">Home</small>
              </a>
            </li>
          </ul>

        </div>
      </div>
    </nav>
  </header>

  <div class="container bd-gutter mt-3 my-md-4 bd-layout">
    <aside class="bd-sidebar scrollBar">
        <div class="offcanvas-lg offcanvas-start" tabindex="-1" id="bdSidebar"
            aria-labelledby="bdSidebarOffcanvasLabel">
            <div class="offcanvas-header border-bottom">
                <h5 class="offcanvas-title" id="bdSidebarOffcanvasLabel">학습목차</h5>
                <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"
                    data-bs-target="#bdSidebar"></button>
            </div>

            <div class="offcanvas-body">
                <!-- 네비게이션 -->
                <nav class="bd-links w-100" id="bd-docs-nav" aria-label="Docs navigation">
  <ul class="bd-links-nav list-unstyled mb-0 pb-3 pb-md-2 pe-lg-2">
    <li class="bd-links-group py-2">
      <strong class="bd-links-heading d-flex w-100 align-items-center fw-semibold">
        강의 목차
      </strong>
      <ul class="list-unstyled fw-normal pb-2 small">
        
        

        
        <li>
          
          
          
          <button
            class="bd-links-link bd-links-btn btn d-inline-flex align-items-center rounded border-0 collapsed w-100"
            data-bs-toggle="collapse" data-bs-target="#collapse-1"
            aria-expanded="false">
            21. 멀티 스레드
            <svg class="bi ms-auto" width="1em" height="1em" viewBox="0 0 16 16" fill="currentColor"
              xmlns="http://www.w3.org/2000/svg">
              <path fill-rule="evenodd"
                d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z" />
            </svg>
          </button>
          <div class="collapse " id="collapse-1">
            <ul class="list-unstyled fw-normal pb-1 small ms-3">
              
              <li>
                <a href="/part03/thread"
                  class="bd-links-link d-inline-block rounded ">
                  학습목표
                </a>
              </li>
              
              <li>
                <a href="/part03/thread/concept"
                  class="bd-links-link d-inline-block rounded ">
                  21.1 멀티 스레드 개념
                </a>
              </li>
              
              <li>
                <a href="/part03/thread/main-thread"
                  class="bd-links-link d-inline-block rounded ">
                  21.2 메인 스레드
                </a>
              </li>
              
              <li>
                <a href="/part03/thread/worker-thread"
                  class="bd-links-link d-inline-block rounded ">
                  21.3 작업 스레드 생성과 실행
                </a>
              </li>
              
              <li>
                <a href="/part03/thread/thread-name"
                  class="bd-links-link d-inline-block rounded ">
                  21.4 스레드 이름
                </a>
              </li>
              
              <li>
                <a href="/part03/thread/thread-state"
                  class="bd-links-link d-inline-block rounded ">
                  21.5 스레드 상태
                </a>
              </li>
              
              <li>
                <a href="/part03/thread/synchronization"
                  class="bd-links-link d-inline-block rounded ">
                  21.6 스레드 동기화
                </a>
              </li>
              
              <li>
                <a href="/part03/thread/safe-stop"
                  class="bd-links-link d-inline-block rounded ">
                  21.7 스레드 안전 종료
                </a>
              </li>
              
              <li>
                <a href="/part03/thread/daemon"
                  class="bd-links-link d-inline-block rounded ">
                  21.8 데몬 스레드
                </a>
              </li>
              
              <li>
                <a href="/part03/thread/thread-pool"
                  class="bd-links-link d-inline-block rounded ">
                  21.9 스레드풀
                </a>
              </li>
              
              <li>
                <a href="/part03/thread/virtual-thread"
                  class="bd-links-link d-inline-block rounded ">
                  21.10 가상 스레드
                </a>
              </li>
              
              <li>
                <a href="/part03/thread/quiz"
                  class="bd-links-link d-inline-block rounded ">
                  확인문제
                </a>
              </li>
              
            </ul>
          </div>
          
        </li>
        
        <li>
          
          
          
          <button
            class="bd-links-link bd-links-btn btn d-inline-flex align-items-center rounded border-0 collapsed w-100"
            data-bs-toggle="collapse" data-bs-target="#collapse-2"
            aria-expanded="false">
            22. 스트림과 병렬 처리
            <svg class="bi ms-auto" width="1em" height="1em" viewBox="0 0 16 16" fill="currentColor"
              xmlns="http://www.w3.org/2000/svg">
              <path fill-rule="evenodd"
                d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z" />
            </svg>
          </button>
          <div class="collapse " id="collapse-2">
            <ul class="list-unstyled fw-normal pb-1 small ms-3">
              
              <li>
                <a href="/part03/io"
                  class="bd-links-link d-inline-block rounded ">
                  학습목표
                </a>
              </li>
              
              <li>
                <a href="/part03/io/intro"
                  class="bd-links-link d-inline-block rounded ">
                  22.1 스트림이란?
                </a>
              </li>
              
              <li>
                <a href="/part03/io/internal-iterator"
                  class="bd-links-link d-inline-block rounded ">
                  22.2 내부 반복자
                </a>
              </li>
              
              <li>
                <a href="/part03/io/intermediate-terminal"
                  class="bd-links-link d-inline-block rounded ">
                  22.3 중간 처리와 최종 처리
                </a>
              </li>
              
              <li>
                <a href="/part03/io/resource"
                  class="bd-links-link d-inline-block rounded ">
                  22.4 리소스로부터 스트림 얻기
                </a>
              </li>
              
              <li>
                <a href="/part03/io/filtering"
                  class="bd-links-link d-inline-block rounded ">
                  22.5 요소 걸러내기(필터링)
                </a>
              </li>
              
              <li>
                <a href="/part03/io/mapping"
                  class="bd-links-link d-inline-block rounded ">
                  22.6 요소 변환(매핑)
                </a>
              </li>
              
              <li>
                <a href="/part03/io/sorting"
                  class="bd-links-link d-inline-block rounded ">
                  22.7 요소 정렬
                </a>
              </li>
              
              <li>
                <a href="/part03/io/looping"
                  class="bd-links-link d-inline-block rounded ">
                  22.8 요소를 하나씩 처리(루핑)
                </a>
              </li>
              
              <li>
                <a href="/part03/io/matching"
                  class="bd-links-link d-inline-block rounded ">
                  22.9 요소 조건 만족 여부(매칭)
                </a>
              </li>
              
              <li>
                <a href="/part03/io/basic-aggregate"
                  class="bd-links-link d-inline-block rounded ">
                  22.10 요소 기본 집계
                </a>
              </li>
              
              <li>
                <a href="/part03/io/custom-aggregate"
                  class="bd-links-link d-inline-block rounded ">
                  22.11 요소 커스텀 집계
                </a>
              </li>
              
              <li>
                <a href="/part03/io/collect"
                  class="bd-links-link d-inline-block rounded ">
                  22.12 요소 수집
                </a>
              </li>
              
              <li>
                <a href="/part03/io/parallel"
                  class="bd-links-link d-inline-block rounded ">
                  22.13 요소 병렬 처리
                </a>
              </li>
              
              <li>
                <a href="/part03/io/charset"
                  class="bd-links-link d-inline-block rounded ">
                  22.14 기본 문자셋 변경
                </a>
              </li>
              
              <li>
                <a href="/part03/io/quiz"
                  class="bd-links-link d-inline-block rounded ">
                  확인문제
                </a>
              </li>
              
            </ul>
          </div>
          
        </li>
        
        <li>
          
          
          
          <button
            class="bd-links-link bd-links-btn btn d-inline-flex align-items-center rounded border-0 collapsed w-100"
            data-bs-toggle="collapse" data-bs-target="#collapse-3"
            aria-expanded="false">
            23. 데이터 입출력
            <svg class="bi ms-auto" width="1em" height="1em" viewBox="0 0 16 16" fill="currentColor"
              xmlns="http://www.w3.org/2000/svg">
              <path fill-rule="evenodd"
                d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z" />
            </svg>
          </button>
          <div class="collapse " id="collapse-3">
            <ul class="list-unstyled fw-normal pb-1 small ms-3">
              
              <li>
                <a href="/part03/stream"
                  class="bd-links-link d-inline-block rounded ">
                  학습목표
                </a>
              </li>
              
              <li>
                <a href="/part03/stream/intro"
                  class="bd-links-link d-inline-block rounded ">
                  23.1 입출력 스트림
                </a>
              </li>
              
              <li>
                <a href="/part03/stream/byte-output"
                  class="bd-links-link d-inline-block rounded ">
                  23.2 바이트 출력 스트림
                </a>
              </li>
              
              <li>
                <a href="/part03/stream/byte-input"
                  class="bd-links-link d-inline-block rounded ">
                  23.3 바이트 입력 스트림
                </a>
              </li>
              
              <li>
                <a href="/part03/stream/char-io"
                  class="bd-links-link d-inline-block rounded ">
                  23.4 문자 입출력 스트림
                </a>
              </li>
              
              <li>
                <a href="/part03/stream/buffer"
                  class="bd-links-link d-inline-block rounded ">
                  23.5 보조 스트림
                </a>
              </li>
              
              <li>
                <a href="/part03/stream/char-convert"
                  class="bd-links-link d-inline-block rounded ">
                  23.6 문자 변환 스트림
                </a>
              </li>
              
              <li>
                <a href="/part03/stream/performance"
                  class="bd-links-link d-inline-block rounded ">
                  23.7 성능 향상 스트림
                </a>
              </li>
              
              <li>
                <a href="/part03/stream/primitive"
                  class="bd-links-link d-inline-block rounded ">
                  23.8 기본 타입 스트림
                </a>
              </li>
              
              <li>
                <a href="/part03/stream/print"
                  class="bd-links-link d-inline-block rounded ">
                  23.9 프린트 스트림
                </a>
              </li>
              
              <li>
                <a href="/part03/stream/object"
                  class="bd-links-link d-inline-block rounded ">
                  23.10 객체 스트림
                </a>
              </li>
              
              <li>
                <a href="/part03/stream/file"
                  class="bd-links-link d-inline-block rounded ">
                  23.11 File과 Files 클래스
                </a>
              </li>
              
              <li>
                <a href="/part03/stream/quiz"
                  class="bd-links-link d-inline-block rounded ">
                  확인문제
                </a>
              </li>
              
            </ul>
          </div>
          
        </li>
        
        <li>
          
          
          
          <button
            class="bd-links-link bd-links-btn btn d-inline-flex align-items-center rounded border-0 collapsed w-100"
            data-bs-toggle="collapse" data-bs-target="#collapse-4"
            aria-expanded="false">
            24. 네트워크 입출력
            <svg class="bi ms-auto" width="1em" height="1em" viewBox="0 0 16 16" fill="currentColor"
              xmlns="http://www.w3.org/2000/svg">
              <path fill-rule="evenodd"
                d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z" />
            </svg>
          </button>
          <div class="collapse " id="collapse-4">
            <ul class="list-unstyled fw-normal pb-1 small ms-3">
              
              <li>
                <a href="/part03/tcp"
                  class="bd-links-link d-inline-block rounded ">
                  학습목표
                </a>
              </li>
              
              <li>
                <a href="/part03/tcp/basic"
                  class="bd-links-link d-inline-block rounded ">
                  24.1 네트워크 기초
                </a>
              </li>
              
              <li>
                <a href="/part03/tcp/ip"
                  class="bd-links-link d-inline-block rounded ">
                  24.2 IP 주소 얻기
                </a>
              </li>
              
              <li>
                <a href="/part03/tcp/tcp"
                  class="bd-links-link d-inline-block rounded ">
                  24.3 TCP 네트워킹
                </a>
              </li>
              
              <li>
                <a href="/part03/tcp/udp"
                  class="bd-links-link d-inline-block rounded ">
                  24.4 UDP 네트워킹
                </a>
              </li>
              
              <li>
                <a href="/part03/tcp/server"
                  class="bd-links-link d-inline-block rounded ">
                  24.5 서버의 동시 요청 처리
                </a>
              </li>
              
              <li>
                <a href="/part03/tcp/json"
                  class="bd-links-link d-inline-block rounded ">
                  24.6 JSON 데이터 형식
                </a>
              </li>
              
              <li>
                <a href="/part03/tcp/chat"
                  class="bd-links-link d-inline-block rounded ">
                  24.7 TCP 채팅 프로그램
                </a>
              </li>
              
              <li>
                <a href="/part03/tcp/quiz"
                  class="bd-links-link d-inline-block rounded ">
                  확인문제
                </a>
              </li>
              
            </ul>
          </div>
          
        </li>
        
        <li>
          
          
          
          <button
            class="bd-links-link bd-links-btn btn d-inline-flex align-items-center rounded border-0 collapsed w-100"
            data-bs-toggle="collapse" data-bs-target="#collapse-5"
            aria-expanded="false">
            25. NIO
            <svg class="bi ms-auto" width="1em" height="1em" viewBox="0 0 16 16" fill="currentColor"
              xmlns="http://www.w3.org/2000/svg">
              <path fill-rule="evenodd"
                d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z" />
            </svg>
          </button>
          <div class="collapse " id="collapse-5">
            <ul class="list-unstyled fw-normal pb-1 small ms-3">
              
              <li>
                <a href="/part03/nio"
                  class="bd-links-link d-inline-block rounded ">
                  학습목표
                </a>
              </li>
              
            </ul>
          </div>
          
        </li>
        
      </ul>
    </li>
  </ul>
</nav>
            </div>
        </div>
    </aside>

    <main class="bd-main order-1">
        <nav aria-label="breadcrumb" class="mt-3">
    <ol class="breadcrumb">
        <li class="breadcrumb-item"><a href="/">Home</a></li>
        
        
        
        
        
        
        
        
        
        <li class="breadcrumb-item"><a href="/part03/">Part03</a></li>
        
        
        
        
        
        
        <li class="breadcrumb-item active" aria-current="page">25. NIO 기반 입출력 및 네트워킹</li>
        
        
        
    </ol>
</nav>
        <div class="bd-content ps-lg-2">
            <h1 id="nio-기반-입출력-및-네트워킹">NIO 기반 입출력 및 네트워킹</h1>

<h2 id="01-nio-소개">01. NIO 소개</h2>

<p>Java 4부터 새로운 입출력New Input/Output, NIO이라는 뜻에서 java.nio 패키지가 포함되었는데, Java 7
로 버전 업그레이드가 되면서 자바 IO와 NIO 사이의 일관성 없는 클래스 설계를 바로 잡고 비동기 
채널 등의 네트워크 지원을 대폭 강화한 NIO.2 API가 추가되었다. 
NIO.2는 java.nio2 패키지로 제공되지 않고 기존 java.nio의 하위 패키지(java.nio.channels, 
java.nio.charset, java.nio.file)에 통합되어 있다. 이 책에서는 NIO와 NIO.2를 구별하지 않고 
그냥 NIO로 부르겠다. 다음은 NIO에서 제공하는 패키지에 대해 간략히 설명한 표이다.
NIO 패키지
포함되어 있는 내용
java.nio
다양한 버퍼 클래스
java.nio.channels
파일 채널, TCP 채널, UDP 채널 등의 클래스
java.nio.channels.spi
java.nio.channels 패키지를 위한 서비스 제공자 클래스
java.nio.charset
문자셋, 인코더, 디코더 API
java.nio.charset.spi
java.nio.charset 패키지를 위한 서비스 제공자 클래스
java.nio.file
파일 및 파일 시스템에 접근하기 위한 클래스
java.nio.file.attribute
파일 및 파일 시스템의 속성에 접근하기 위한 클래스
java.nio.file.spi
java.nio.file 패키지를 위한 서비스 제공자 클래스
IO와 NIO의 차이점
IO와 NIO는 데이터를 입출력한다는 목적은 동일하지만 방식에 있어서 크게 차이가 난다. 다음 표
는 IO와 NIO의 차이점을 정리한 것이다.
구분
IO
NIO
입출력 방식
스트림 방식(단방향)
채널 방식(양방향)
버퍼 방식
넌버퍼(non-buffer)
버퍼(buffer)
비동기 방식
지원 안 함
지원</p>

<h3 id="1-스트림-vs-채널">1) 스트림 vs. 채널</h3>

<p>IO는 단방향 스트림Stream 기반이다. 스트림은 입력 스트림과 출력 스트림으로 구분되어 있기 때문
에 데이터를 읽기 위해서는 입력 스트림을 생성해야 하고, 데이터를 출력하기 위해서는 출력 스트
림을 생성해야 한다. 예를 들어 하나의 파일에서 데이터를 읽고 저장하는 작업을 모두 해야 한다면 
FileInputStream과 FileOutputStream을 별도로 생성해야 한다.
NIO는 채널Channel 기반이다. 채널은 스트림과 달리 양방향으로 입력과 출력이 가능하다. 그렇기 때
문에 입력과 출력을 위한 별도의 채널을 만들 필요가 없다. 예를 들어 하나의 파일에서 데이터를 읽
고 저장하는 작업을 모두 해야 한다면 FileChannel 하나만 생성하면 된다.</p>

<h3 id="2-넌버퍼-vs-버퍼">2) 넌버퍼 vs. 버퍼</h3>

<p>IO에서는 출력 스트림이 1바이트를 쓰면 입력 스트림이 1바이트를 읽는다. 이런 시스템은 대체
로 속도가 느리다. 따라서 이것보다는 버퍼Buffer: 메모리 저장소를 사용해서 복수 개의 바이트를 한꺼번
에 입력받고 출력하는 것이 빠른 성능을 낸다. 그래서 IO는 버퍼를 제공해주는 보조 스트림인 
BufferedInputStream, BufferedOutputStream을 연결해서 사용하기도 한다. 
NIO는 기본적으로 버퍼를 사용해서 입출력을 하기 때문에 IO보다는 입출력 성능이 좋다. 채널은 
버퍼에 저장된 데이터를 출력하고, 입력된 데이터를 버퍼에 저장한다.
IO
NIO</p>
<ol>
  <li>파일</li>
  <li>네트워크</li>
  <li>파일</li>
  <li>네트워크
입력
데이터
출력
데이터
입력 스트림
채널
버
퍼
출력 스트림</li>
  <li>파일</li>
  <li>네트워크
IO는 스트림에서 입력된 데이터를 별도로 저장하지 않으면 입력된 데이터의 위치를 이동해가면서 
자유롭게 읽을 수 없다. 반면 NIO는 읽은 데이터를 무조건 버퍼에 저장하기 때문에 버퍼 내에서 데
이터의 위치를 이동해가면서 필요한 부분만 읽을 수 있다.</li>
</ol>

<p>IO와 NIO의 선택
NIO는 스레드풀을 이용한 비동기로 처리할 수 있기 때문에 스레드를 효과적으로 재사용한다는 점
에서 큰 장점이 있다. 또한 운영체제의 버퍼(다이렉트 버퍼)를 이용한 입출력이 가능하기 때문에 입
출력 성능이 향상된다.
NIO는 처리 작업 수가 많고 하나의 작업이 오래 걸리지 않는 경우에 사용하는 것이 좋다. 반대로 처
리 작업 수가 적고, 데이터가 대용량이면서 순차적으로 처리될 필요성이 있을 경우에는 IO로 구현
하는 것이 좋다. 대용량 데이터일 경우에는 NIO 버퍼 크기가 문제가 되기 때문이다.</p>

<h2 id="02-파일과-디렉토리">02. 파일과 디렉토리</h2>

<p>IO는 파일의 속성 정보를 읽기 위해 File 클래스만 제공하지만, NIO는 좀 더 다양한 파일의 속성 
정보를 제공해주는 클래스와 인터페이스를 java.nio.file, java.nio.file.attribute 패키지에서 제
공한다.
Path 클래스
Path는 IO의 java.io.File 클래스에 대응되는 NIO 인터페이스이다. NIO에서는 파일 경로를 지정
할 때 Path를 사용하기 때문에 Path 사용 방법을 잘 익혀두어야 한다. Path 구현 객체를 얻기 위해
서는 java.nio.file.Paths 클래스의 정적 메소드인 get( ) 메소드를 호출하면 된다.
Path path = Paths.get(String first, String… more)
Path path = Paths.get(URI uri);
get( ) 메소드의 매개값은 파일의 경로인데, 문자열로 지정할 수도 있고 URI 객체로도 지정할 수 있
다. 문자열로 지정할 경우 전체 경로를 한꺼번에 지정해도 좋고, 상위 디렉토리와 하위 디렉토리를 
나열해서 지정해도 좋다. 
다음은 ‘C:\Temp\dir\file.txt’ 경로를 이용해서 Path 객체를 얻는 방법이다.
Path path = Paths.get(“C:/Temp/dir/file.txt”);
Path path = Paths.get(“C:/Temp/dir”, “file.txt”);
Path path = Paths.get(“C:”, “Temp”, “dir”, “file.txt”);</p>

<p>파일의 경로는 절대 경로와 상대 경로를 모두 사용할 수 있다. 만약 현재 디렉토리 위치가 ‘C:\Temp’
일 경우 ‘C:\Temp\dir\file.txt’는 다음과 같이 지정이 가능하다.
Path path = Paths.get(“dir/file.txt”);
Path path = Paths.get(“./dir/file.txt”);
현재 위치가 ‘C:\Temp\dir1’이라면 ‘C:\Temp\dir2\file.txt’는 다음과 같이 지정할 수 있다.
Path path = Paths.get(“../dir2/file.txt”);
Path 인터페이스에는 다음과 같이 파일 경로에서 얻을 수 있는 여러 가지 정보를 제공하는 메소드
가 있다.
리턴 타입
메소드(매개변수)
설명
int
compareTo(Path other)
파일 경로가 동일하면 0을 리턴, 
상위 경로면 음수, 
하위 경로면 양수를 리턴, 
음수와 양수의 값은 차이나는 문자열의 수
Path
getFileName( )
부모 경로를 제외한 파일 이름만 가진 Path 리턴
FileSystem
getFileSystem( )
FileSystem 객체 리턴
Path
getName(int index)
C:/Temp/dir/file.txt일 경우 
index가 0이면 ‘Temp’의 Path 객체 리턴 
index가 1이면 ‘dir’의 Path 객체 리턴 
index가 2이면 ‘file.txt’의 Path 객체 리턴
int
getNameCount( )
중첩 경로의 수. C:/Temp/dir/file.txt일 경우 3을 리턴
Path
getParent( )
바로 위 부모 폴더의 Path 리턴
Path
getRoot( )
루트 디렉토리의 Path 리턴
Iterator<Path>
iterator( )
경로에 있는 모든 디렉토리와 파일을 Path 객체로 생성하고 
반복자를 리턴
Path
normalize( )
상대 경로로 표기할 때 불필요한 요소를 제거
C:/Temp/dir1/../dir2/file.txt → C:/Temp/dir2/file.txt
WatchKey
register(...)
WatchService를 등록(와치 서비스에서 설명함)
File
toFile( )
java.io.File 객체로 리턴
String
toString( )
파일 경로를 문자열로 리턴
URI
toUri( )
파일 경로를 URI 객체로 리턴</Path></p>

<p>다음 예제는 상대 경로를 이용해서 Path 객체를 얻고 파일명, 부모 디렉토리명, 중첩 경로 수, 경로
상에 있는 모든 디렉토리를 출력한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">sec02.exam01_path</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.file.Path</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.file.Paths</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Iterator</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PathExample</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
  <span class="nc">Path</span> <span class="n">path</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"src/sec02/exam01_path/PathExample.java"</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[파일명] "</span> <span class="o">+</span> <span class="n">path</span><span class="o">.</span><span class="na">getFileName</span><span class="o">());</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[부모 디렉토리명]: "</span> <span class="o">+</span> <span class="n">path</span><span class="o">.</span><span class="na">getParent</span><span class="o">().</span><span class="na">getFileName</span><span class="o">());</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[중첩 경로 수]: "</span> <span class="o">+</span> <span class="n">path</span><span class="o">.</span><span class="na">getNameCount</span><span class="o">());</span>
  
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">path</span><span class="o">.</span><span class="na">getNameCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">path</span><span class="o">.</span><span class="na">getName</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
  <span class="o">}</span>
  
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
  <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Path</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
  <span class="k">while</span><span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
   <span class="nc">Path</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">temp</span><span class="o">.</span><span class="na">getFileName</span><span class="o">());</span>
  <span class="o">}</span>
 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>실행 결과
[파일명] PathExample.java
[부모 디렉토리명]: exam01_path
[중첩 경로 수]: 4
src
sec02
exam01_path</p>

<p>PathExample.java
src
sec02
exam01_path
PathExample.java
FileSystem 클래스
운영체제의 파일 시스템은 FileSystem 인터페이스를 통해서 접근할 수 있다. FileSystem 구현 객
체는 FileSystems의 정적 메소드인 getDefault( )로 얻을 수 있다.
FileSystem fileSystem = FileSystems.getDefault();
FileSystem은 다음과 같은 메소드를 제공한다.
리턴타입
메소드(매개변수)
설명
Iterable<FileStore>
getFileStores( )
드라이버 정보를 가진 FileStore 객체들을 리턴
Iterable<Path>
getRootDirectories( )
루트 디렉토리 정보를 가진 Path 객체들을 리턴
String
getSeparator( )
디렉토리 구분자 리턴
FileStore는 드라이버를 표현한 객체로 다음과 같은 메소드를 제공한다.
리턴 타입
메소드(매개변수)
설명
long
getTotalSpace( )
드라이버 전체 공간 크기(단위: 바이트) 리턴
long
getUnallocatedSpace( )
할당되지 않은 공간 크기(단위: 바이트) 리턴
long
getUsableSpace( )
사용 가능한 공간 크기, getUnallocatedSpace( )와 동일값
boolean
isReadOnly( )
읽기 전용 여부
String
name( )
드라이버명 리턴
String
type( )
파일 시스템 종류
다음 예제는 드라이버명과 파일 시스템에 대한 정보를 보여준다.</Path></FileStore></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">sec02.exam02_filesystem</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.file.FileStore</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.file.FileSystem</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.file.FileSystems</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.file.Path</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FileSystemExample</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
  <span class="nc">FileSystem</span> <span class="n">fileSystem</span> <span class="o">=</span> <span class="nc">FileSystems</span><span class="o">.</span><span class="na">getDefault</span><span class="o">();</span>
  <span class="k">for</span><span class="o">(</span><span class="nc">FileStore</span> <span class="n">store</span> <span class="o">:</span> <span class="n">fileSystem</span><span class="o">.</span><span class="na">getFileStores</span><span class="o">())</span> <span class="o">{</span>
   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"드라이버명: "</span> <span class="o">+</span> <span class="n">store</span><span class="o">.</span><span class="na">name</span><span class="o">());</span>
   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"파일시스템: "</span> <span class="o">+</span> <span class="n">store</span><span class="o">.</span><span class="na">type</span><span class="o">());</span>
   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"전체 공간: \t\t"</span> <span class="o">+</span> <span class="n">store</span><span class="o">.</span><span class="na">getTotalSpace</span><span class="o">()</span> <span class="o">+</span> <span class="s">" 바이트"</span><span class="o">);</span>
   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"사용 중인 공간: \t"</span> <span class="o">+</span> 
     <span class="o">(</span><span class="n">store</span><span class="o">.</span><span class="na">getTotalSpace</span><span class="o">()</span> <span class="o">-</span> <span class="n">store</span><span class="o">.</span><span class="na">getUnallocatedSpace</span><span class="o">())</span> <span class="o">+</span> <span class="s">" 바이트"</span><span class="o">);</span>
   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"사용 가능한 공간: \t"</span> <span class="o">+</span> <span class="n">store</span><span class="o">.</span><span class="na">getUsableSpace</span><span class="o">()</span> <span class="o">+</span> 
 
     <span class="s">" 바이트"</span><span class="o">);</span>
   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
  <span class="o">}</span>
  
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"파일 구분자: "</span> <span class="o">+</span> <span class="n">fileSystem</span><span class="o">.</span><span class="na">getSeparator</span><span class="o">());</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
  
  <span class="k">for</span><span class="o">(</span><span class="nc">Path</span> <span class="n">path</span> <span class="o">:</span> <span class="n">fileSystem</span><span class="o">.</span><span class="na">getRootDirectories</span><span class="o">())</span> <span class="o">{</span>
   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">path</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
  <span class="o">}</span>
 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>실행 결과
드라이버명: 운영체제
파일시스템: NTFS
전체 공간: 255382777856 바이트
사용 중인 공간: 135942008832 바이트
사용 가능한 공간: 119440769024 바이트
드라이버명: 작업디스크</p>

<p>파일시스템: NTFS
전체 공간: 256058060800 바이트
사용 중인 공간: 197464064 바이트
사용 가능한 공간: 255860596736 바이트
드라이버명: 로컬디스크
파일시스템: NTFS
전체 공간: 8001545039872 바이트
사용 중인 공간: 1677118210048 바이트
사용 가능한 공간: 6324426829824 바이트
파일 구분자: <br />
C:<br />
D:<br />
E:<br />
Files 클래스
Files 클래스는 파일과 디렉토리 생성 및 삭제, 그리고 이들의 속성을 읽는 메소드를 제공하고 있다. 
여기서 속성이란 파일이나 디렉토리가 숨김인지, 디렉토리인지, 크기가 어떻게 되는지, 소유자가 누
구인지에 대한 정보를 말한다. 
다음은 Files 클래스가 제공하는 정적 메소드들이다. 매개변수에 대한 자세한 설명은 API 도큐먼트
를 참조하길 바란다.
리턴 타입
메소드(매개변수)
설명
long 또는 Path
copy(…)
복사
Path
createDirectories(…)
경로에 있는 모든 디렉토리 생성
Path
createDirectory(…)
경로의 마지막 디렉토리만 생성
Path
createFile(…)
파일 생성
void
delete(…)
삭제
boolean
deleteIfExists(…)
존재한다면 삭제
boolean
exists(…)
존재 여부
FileStore
getFileStore(…)
파일이 위치한 FileStore(드라이브) 리턴</p>

<p>FileTime
getLastModifiedTime(…)
마지막 수정 시간을 리턴
UserPrincipal
getOwner(…)
소유자 정보를 리턴
boolean
isDirectory(…)
디렉토리인지 여부
boolean
isExecutable(…)
실행 가능 여부
boolean
isHidden(…)
숨김 여부
boolean
isReadable(…)
읽기 가능 여부
boolean
isRegularFile(…)
일반 파일인지 여부
boolean
isSameFile(…)
같은 파일인지 여부
boolean
isWritable(…)
쓰기 가능 여부
Path
move(…)
파일 이동
BufferedReader
newBufferedReader(…)
텍스트 파일을 읽는 BufferedReader 리턴
BufferedWriter
newBufferedWriter(…)
텍스트 파일에 쓰는 BufferedWriter 리턴
SeekableByteChannel
newByteChannel(…)
파일에 읽고 쓰는 바이트 채널을 리턴
DirectoryStream<Path>
newDirectoryStream(...)
디렉토리의 모든 내용을 스트림으로 리턴
InputStream
newInputStream(...)
파일의 InputStream 리턴
OutputStream
newOutputStream(...)
파일의 OutputStream 리턴
boolean
notExists(...)
존재하지 않는지 여부
String
probeContentType(...)
파일의 MIME 타입을 리턴
byte[ ]
readAllBytes(...)
파일의 모든 바이트를 읽고 배열로 리턴
List<String>
readAllLines(...)
텍스트 파일의 모든 라인을 읽고 리턴
long
size(...)
파일의 크기 리턴
Path
write(...)
파일에 바이트나 문자열을 저장
다음 예제는 파일의 속성을 읽고 출력한다.</String></Path></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">sec02.exam03_file_directory</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.file.Files</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.file.Path</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.file.Paths</span><span class="o">;</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FileExample</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
  <span class="nc">Path</span> <span class="n">path</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"src/sec02/exam03_file_directory/
 
    FileExample.java"</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"디렉토리 여부: "</span> <span class="o">+</span> <span class="nc">Files</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">(</span><span class="n">path</span><span class="o">));</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"파일 여부: "</span> <span class="o">+</span> <span class="nc">Files</span><span class="o">.</span><span class="na">isRegularFile</span><span class="o">(</span><span class="n">path</span><span class="o">));</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"마지막 수정 시간: "</span> <span class="o">+</span> <span class="nc">Files</span><span class="o">.</span><span class="na">getLastModifiedTime</span>
 
    <span class="o">(</span><span class="n">path</span><span class="o">));</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"파일 크기: "</span> <span class="o">+</span> <span class="nc">Files</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="n">path</span><span class="o">));</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"소유자: "</span> <span class="o">+</span> <span class="nc">Files</span><span class="o">.</span><span class="na">getOwner</span><span class="o">(</span><span class="n">path</span><span class="o">).</span><span class="na">getName</span><span class="o">());</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"숨김 파일 여부: "</span> <span class="o">+</span> <span class="nc">Files</span><span class="o">.</span><span class="na">isHidden</span><span class="o">(</span><span class="n">path</span><span class="o">));</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"읽기 가능 여부: "</span> <span class="o">+</span> <span class="nc">Files</span><span class="o">.</span><span class="na">isReadable</span><span class="o">(</span><span class="n">path</span><span class="o">));</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"쓰기 가능 여부: "</span> <span class="o">+</span> <span class="nc">Files</span><span class="o">.</span><span class="na">isWritable</span><span class="o">(</span><span class="n">path</span><span class="o">));</span>
 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>실행 결과</strong></p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>디렉토리 여부: false
파일 여부: true
마지막 수정 시간: 2022-03-15T11:13:32.1599634Z
파일 크기: 883
소유자: BLUESKII-REMOTE\blueskii
숨김 파일 여부: false
읽기 가능 여부: true
쓰기 가능 여부: true
다음 예제는 디렉토리와 파일을 생성하고, 디렉토리의 내용을 출력한다. 예제를 실행하려면 C:/Temp 
디렉토리가 존재해야 한다. 없다면 생성 후 실행하자.

```java
package sec02.exam03_file_directory;
import java.io.IOException;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.nio.file.Path</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.file.Paths</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DirectoryExample</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">try</span> <span class="o">{</span>
   <span class="c1">//디렉토리 및 파일 생성</span>
   <span class="nc">Path</span> <span class="n">path</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"C:/Temp/file1.txt"</span><span class="o">);</span>
   <span class="k">if</span><span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">notExists</span><span class="o">(</span><span class="n">path</span><span class="o">))</span> <span class="o">{</span> <span class="nc">Files</span><span class="o">.</span><span class="na">createFile</span><span class="o">(</span><span class="n">path</span><span class="o">);</span> <span class="o">}</span>
   <span class="n">path</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"C:/Temp/dir1"</span><span class="o">);</span> 
 
   <span class="k">if</span><span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">notExists</span><span class="o">(</span><span class="n">path</span><span class="o">))</span> <span class="o">{</span> <span class="nc">Files</span><span class="o">.</span><span class="na">createDirectories</span><span class="o">(</span><span class="n">path</span><span class="o">);</span> <span class="o">}</span>
   <span class="n">path</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"C:/Temp/dir1/file2.txt"</span><span class="o">);</span> 
 
   <span class="k">if</span><span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">notExists</span><span class="o">(</span><span class="n">path</span><span class="o">))</span> <span class="o">{</span> <span class="nc">Files</span><span class="o">.</span><span class="na">createFile</span><span class="o">(</span><span class="n">path</span><span class="o">);</span> <span class="o">}</span>
   <span class="n">path</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"C:/Temp/dir1/dir2"</span><span class="o">);</span>  
   <span class="k">if</span><span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">notExists</span><span class="o">(</span><span class="n">path</span><span class="o">))</span> <span class="o">{</span> <span class="nc">Files</span><span class="o">.</span><span class="na">createDirectories</span><span class="o">(</span><span class="n">path</span><span class="o">);</span> <span class="o">}</span>
   <span class="n">path</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"C:/Temp/dir1/dir2/file3.txt"</span><span class="o">);</span> 
 
   <span class="k">if</span><span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">notExists</span><span class="o">(</span><span class="n">path</span><span class="o">))</span> <span class="o">{</span> <span class="nc">Files</span><span class="o">.</span><span class="na">createFile</span><span class="o">(</span><span class="n">path</span><span class="o">);</span> <span class="o">}</span>
   
   <span class="n">path</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"C:/Temp"</span><span class="o">);</span>
   <span class="n">printDirContent</span><span class="o">(</span><span class="n">path</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
  <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
  <span class="o">}</span>
 <span class="o">}</span>
 
 <span class="c1">//디렉토리 내용 출력</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printDirContent</span><span class="o">(</span><span class="nc">Path</span> <span class="n">path</span><span class="o">,</span> <span class="kt">int</span> <span class="n">indent</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">try</span> <span class="o">{</span>
   <span class="c1">//파일들만 출력</span>
   <span class="nc">DirectoryStream</span><span class="o">&lt;</span><span class="nc">Path</span><span class="o">&gt;</span> <span class="n">directoryStream</span> <span class="o">=</span> <span class="nc">Files</span><span class="o">.</span><span class="na">newDirectoryStream</span>
 
     <span class="o">(</span><span class="n">path</span><span class="o">);</span>
   <span class="n">directoryStream</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(!</span><span class="nc">Files</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">(</span><span class="n">p</span><span class="o">))</span> <span class="o">{</span>
     <span class="c1">//들여쓰기</span>
     <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">indent</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"\t"</span><span class="o">);</span> <span class="o">}</span>
     <span class="c1">//파일 이름과 크기 출력</span>
     <span class="k">try</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">getFileName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" (크기:"</span> <span class="o">+</span> <span class="nc">Files</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> 
 
          <span class="o">+</span> <span class="s">")"</span><span class="o">);</span>
     <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>


      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
     <span class="o">}</span>
    <span class="o">}</span>
   <span class="o">});</span>
   
   <span class="c1">//디렉토리들만 출력</span>
   <span class="n">directoryStream</span> <span class="o">=</span> <span class="nc">Files</span><span class="o">.</span><span class="na">newDirectoryStream</span><span class="o">(</span><span class="n">path</span><span class="o">);</span>
   <span class="n">directoryStream</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">(</span><span class="n">p</span><span class="o">))</span> <span class="o">{</span>
     <span class="c1">//들여쓰기</span>
     <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">indent</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"\t"</span><span class="o">);</span> <span class="o">}</span>
     <span class="c1">//디렉토리 이름 출력</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"["</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="na">getFileName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">);</span>
     <span class="c1">//재귀호출, 들여쓰기를 1 추가함</span>
     <span class="n">printDirContent</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">indent</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
   <span class="o">});</span>
  <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
  <span class="o">}</span>
 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>실행 결과</strong></p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>file1.txt (크기:0)
[dir1]
  file2.txt (크기:0)
  [dir2]
    file3.txt (크기:0)

## 03. 버퍼

NIO에서는 데이터를 입출력하기 위해 항상 버퍼를 사용해야 한다. 버퍼Buffer는 읽고 쓰기가 가능한 
메모리 배열이다. 버퍼를 이해하고 잘 사용할 수 있어야 NIO에서 제공하는 API를 올바르게 활용할 
수 있다.


프로그램
버
퍼
채널
1. 파일
2. 네트워크
입력
데이터
출력
데이터
버퍼 종류
버퍼는 저장되는 데이터 타입에 따라 분류될 수 있고, 어떤 메모리를 사용하느냐에 따라 다이렉트Direct
와 넌다이렉트NonDirect로 분류할 수도 있다.

### 1) 데이터 타입에 따른 버퍼

NIO 버퍼는 저장되는 데이터 타입에 따라서 별도의 클래스로 제공된다. 이 버퍼 클래스들은 Buffer 
추상 클래스를 모두 상속하고 있다.
FloatBuffer
DoubleBuffer
Buffer
CharBuffer
ShortBuffer
IntBuffer
LongBuffer
ByteBuffer
MappedByteBuffer
버퍼 클래스의 이름을 보면 어떤 데이터가 저장되는 버퍼인지 쉽게 알 수 있다. ByteBuffer는 
byte 데이터가 저장되고, CharBuffer, ShortBuffer, IntBuffer, LongBuffer, FloatBuffer, 
DoubleBuffer는 각각 char, short, int, long, float, double 데이터가 저장되는 버퍼이다.


MappedByteBuffer는 ByteBuffer의 하위 클래스로 파일의 내용에 랜덤하게 접근하기 위해서 
파일의 내용을 메모리와 맵핑시킨 버퍼이다.

### 2) 넌다이렉트와 다이렉트 버퍼

버퍼가 생성되는 메모리의 위치에 따라서 넌다이렉트non-direct 버퍼와 다이렉트direct 버퍼로 분류된다. 
넌다이렉트 버퍼는 JVM이 관리하는 힙 메모리 공간에 생성되는 버퍼이고, 다이렉트 버퍼는 운영체
제가 관리하는 메모리 공간에 생성되는 버퍼이다. 두 버퍼의 특징은 다음과 같다.
구분
넌다이렉트 버퍼
다이렉트 버퍼
사용하는 메모리 공간
JVM의 힙 메모리
운영체제의 메모리
버퍼 생성 시간
버퍼 생성이 빠르다.
버퍼 생성이 느리다.
버퍼의 크기
작다.
크다(큰 데이터를 처리할 때 유리).
입출력 성능
낮다.
높다(입출력이 빈번할 경우 유리).
●  넌다이렉트 버퍼는 JVM 힙 메모리를 사용하므로 버퍼 생성 시간이 빠르지만, 다이렉트 버퍼는 운영체제로부터 
메모리를 할당받아야 하므로 상대적으로 버퍼 생성이 느리다. 그렇기 때문에 다이렉트 버퍼는 자주 생성하기보다
는 한 번 생성해 놓고 재사용하는 것이 적합하다. 
●  넌다이렉트 버퍼는 JVM의 제한된 힙메모리를 사용하므로 버퍼의 크기를 작게 잡는 것이 좋고, 다이렉트 버퍼는 
운영체제가 관리하는 메모리를 사용하므로 운영체제가 허용하는 범위 내에서 대용량 버퍼를 생성시킬 수 있다. 
●  넌다이렉트 버퍼는 I/O(입출력)를 하기 위해 임시 다이렉트 버퍼를 생성하고 넌다이렉트 버퍼에 있는 내용을 임
시 다이렉트 버퍼에 복사한다. 그리고 나서 임시 다이렉트 버퍼의 내용으로 운영체제의 I/O기능을 수행한다. 그
렇기 때문에 직접 다이렉트 버퍼를 사용하는 것보다는 I/O 성능이 낮다.
버퍼 생성
각 데이터 타입별로 넌다이렉트 버퍼를 생성하기 위해서는 각 Buffer 클래스의 allocate( )와 wrap( ) 
메소드를 이용하고, 다이렉트 버퍼는 ByteBuffer의 allocateDirect( ) 메소드를 이용한다.

### 1) allocate()와 wrap() 메소드

데이터 타입별로 Buffer의 allocate( ) 메소드를 호출하면 JVM 힙 메모리에 넌다이렉트 버퍼를 생
성한다. capacity 매개값은 데이터 저장 개수이다.


리턴 타입
메소드(매개변수)
설명
ByteBuffer
ByteBuffer.allocate(int capacity)
capacity개의 byte 값을 저장하는 버퍼 생성
CharBuffer
CharBuffer.allocate(int capacity)
capacity개의 char 값을 저장하는 버퍼 생성
DoubleBuffer
DoubleBuffer.allocate(int capacity)
capacity개의 double 값을 저장하는 버퍼 생성
FloatBuffer
FloatBuffer.allocate(int capacity)
capacity개의 float 값을 저장하는 버퍼 생성
IntBuffer
IntBuffer.allocate(int capacity)
capacity개의 int 값을 저장하는 버퍼 생성
LongBuffer
LongBuffer.allocate(int capacity)
capacity개의 long 값을 저장하는 버퍼 생성
ShortBuffer
ShortBuffer. allocate(int capacity)
capacity개의 short 값을 저장하는 버퍼 생성
다음은 100개의 byte[ ] 값을 저장하는 ByteBuffer와 100개의 int값을 저장하는 CharBuffer를 
생성하는 코드이다.
ByteBuffer buffer = ByteBuffer.allocate(100);
CharBuffer buffer = CharBuffer.allocate(100);
각 데이터 타입별 Buffer 클래스는 모두 wrap( ) 메소드를 가지고 있는데, wrap( ) 메소드는 배열
을 래핑해서 Buffer 객체를 생성한다. 배열은 JVM 힙 메모리에 생성되므로 wrap( )은 넌다이렉트 
버퍼를 생성한다. 
다음은 길이가 100인 byte[ ]를 이용해서 ByteBuffer를 생성하고, 길이가 100인 int[ ]를 이용해서 
CharBuffer를 생성하는 코드이다.
byte[] array = new byte[100];
ByteBuffer buffer = ByteBuffer.wrap(array);
char[] array = new char[100];
CharBuffer buffer = CharBuffer.wrap(array);
배열 전체가 아니라 일부 데이터만 가지고 Buffer 객체를 생성할 수도 있다. 이 경우 시작 인덱스와 
길이를 추가적으로 지정하면 된다. 다음은 0 인덱스부터 50개만 버퍼로 생성하는 코드이다.


byte[] byteArray = new byte[100];
ByteBuffer byteBuffer = ByteBuffer.wrap(byteArray, 0, 50);
CharBuffer는 추가적으로 문자열을 제공해서 CharBuffer를 생성할 수 있는 wrap( ) 메소드도 
제공한다.
CharBuffer charBuffer = CharBuffer.wrap("NIO 입출력은 버퍼를 이용합니다.");
wrap( ) 메소드로 배열을 래핑하는 버퍼를 생성할 경우에는, 버퍼의 array( ) 메소드로 다시 배열을 얻
을 수 있다. 하지만 배열을 래핑하지 않는 버퍼는 사용할 수 없다. 다음은 ByteBuffer와 CharBuffer
가 래핑하고 있는 배열을 얻는 코드이다.
byte[] byteArray1 = new byte[100];
ByteBuffer byteBuffer = ByteBuffer.wrap(byteArray);
byte[] byteArray2 = byteBuffer.arrary();
char[] charArray1 = new char[100];
CharBuffer charBuffer = CharBuffer.wrap(charArray);
char[] charArray2 = charBuffer.arrary();
다음 예제는 allocate( ) 메소드와 wrap( ) 메소드를 이용해서 넌다이렉트 버퍼를 생성하는 방법을 
보여준다.

```java
package sec03.exam01_create_buffer;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.IntBuffer;
import java.util.Arrays;
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NonDirentBufferExample</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">//넌다이렉트 ByteBuffer 생성</span>
  <span class="nc">ByteBuffer</span> <span class="n">buffer1</span> <span class="o">=</span> <span class="nc">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">buffer1</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
  <span class="c1">//넌다이렉트 IntBuffer 생성</span>
  <span class="nc">IntBuffer</span> <span class="n">buffer2</span> <span class="o">=</span> <span class="nc">IntBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">buffer2</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
  
  <span class="c1">//배열을 래ೝ해서 넌다이렉트 ByteBuffer 생성</span>
  <span class="kt">byte</span><span class="o">[]</span> <span class="n">array3</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span> <span class="o">};</span>
  <span class="nc">ByteBuffer</span> <span class="n">buffer3</span> <span class="o">=</span> <span class="nc">ByteBuffer</span><span class="o">.</span><span class="na">wrap</span><span class="o">(</span><span class="n">array3</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">buffer3</span> <span class="o">+</span> <span class="s">", "</span><span class="o">);</span>
  <span class="c1">//래ೝ된 배열을 얻어 출력하기</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">buffer3</span><span class="o">.</span><span class="na">array</span><span class="o">()));</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
  
  <span class="c1">//배열을 래ೝ해서 넌다이렉트 CharBuffer 생성</span>
  <span class="kt">char</span><span class="o">[]</span> <span class="n">array4</span> <span class="o">=</span> <span class="s">"This is Java"</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
  <span class="nc">CharBuffer</span> <span class="n">buffer4</span> <span class="o">=</span> <span class="nc">CharBuffer</span><span class="o">.</span><span class="na">wrap</span><span class="o">(</span><span class="n">array4</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">buffer4</span><span class="o">);</span>
  <span class="c1">//래ೝ된 배열을 얻어 출력하기</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">buffer4</span><span class="o">.</span><span class="na">array</span><span class="o">()));</span>
 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>실행 결과</strong></p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java.nio.HeapByteBuffer[pos=0 lim=100 cap=100]
java.nio.HeapIntBuffer[pos=0 lim=100 cap=100]
java.nio.HeapByteBuffer[pos=0 lim=2 cap=2], 
[10, 20]
This is Java
[T, h, i, s,  , i, s,  , J, a, v, a]



### 3) allocateDirect() 메소드

ByteBuffer의 allocateDirect( ) 메소드는 운영체제가 관리하는 메모리에 다이렉트 버퍼를 생성
한다. 이 메소드는 각 타입별 Buffer 클래스에는 없고, ByteBuffer에서만 제공된다. 다음 예제는 
100개의 byte를 저장하는 다이렉트 ByteBuffer를 생성하는 코드이다. 

```java
package sec03.exam01_create_buffer;
import java.nio.ByteBuffer;
public class DirectBufferExample {
 public static void main(String[] args) {
  //다이렉트 ByteBuffer 생성
  ByteBuffer buffer = ByteBuffer.allocateDirect(100);
  System.out.println(buffer);
 }
}
</code></pre></div></div>

<p>실행 결과
java.nio.DirectByteBuffer[pos=0 lim=100 cap=100]
버퍼 위치 속성
버퍼를 생성하는 방법을 알았으니 이제는 사용하는 방법을 알아보자. 버퍼를 사용하려면 먼저 버퍼
의 위치 속성에 대해 알고 있어야 한다. 다음은 버퍼의 네 가지 위치 속성이다. 
속성
설명
capacity</p>
<ul>
  <li>버퍼에 저장할 수 있는 최대 데이터 수
limit</li>
  <li>읽거나 쓸 수 있는 한계</li>
  <li>버퍼 생성 시 limit과 capacity는 같은 값을 가짐 
position</li>
  <li>현재 읽거나 쓰는 위치</li>
  <li>position이 limit이 되면 더 이상 데이터를 쓰거나 읽을 수 없음
mark</li>
  <li>reset( ) 메소드를 실행했을 때에 되돌아올 위치</li>
  <li>position나 limit의 값이 mark 값보다 작은 경우 mark는 자동 제거</li>
</ul>

<p>position, limit, capacity, mark 속성의 크기 관계는 다음과 같다. mark는 position보다 클 수 
없고, position은 limit보다 클 수 없으며, limit은 capacity보다 클 수 없다.
0  mark  position  limit  capacity
예를 들어 다음 그림처럼 7바이트 크기의 버퍼를 생성했다고 가정해 보자. 처음에는 limit과 
capacity가 동일하게 7이 되고 position은 0이 된다. 버퍼의 크기가 7이므로 인덱스는 6까지이다.
인덱스
Buffer
capacity
limit
position
버퍼가 생성된 후 2바이트를 버퍼에 저장하면 다음 그림과 같이 position이 위치한 0 인덱스부터 
2바이트가 저장되고 position은 2 인덱스로 이동한다.
인덱스
Buffer
capacity
limit
position
계속해서 3바이트를 저장하면 다음 그림과 같이 position 2 인덱스에서 3바이트가 저장되고, 
position은 5 인덱스로 이동한다.
인덱스
Buffer
capacity
limit
position</p>

<p>저장이 완료된 후 버퍼에 저장된 바이트를 읽으려면 먼저 flip( ) 메소드를 호출해야 한다. flip( )을 
호출하면 다음 그림과 같이 limit을 현재 position 5 인덱스로 설정하고, position을 0 인덱스로 
설정한다. 
인덱스
Buffer
capacity
limit
position
flip()
flip()
버퍼에서 3바이트를 읽으면 다음 그림과 같이 position이 위치한 0 인덱스부터 3바이트가 읽혀지
고 position은 3번 인덱스로 이동한다.
인덱스
Buffer
capacity
limit
position
position이 3번 인덱스를 가리키고 있을 때 mark( ) 메소드를 호출해서 다음 그림과 같이 3번 인덱
스를 마킹해놓는다.
인덱스
Buffer
capacity
limit
position
mark
버퍼에서 2바이트를 더 읽으면 다음 그림과 같이 position이 위치한 3 인덱스부터 2바이트가 읽혀
지고 position은 5 인덱스로 이동한다.</p>

<p>인덱스
Buffer
capacity
limit
mark
position
position을 mark 위치로 이동하기 위해 reset( ) 메소드를 호출한다. 다음 그림과 같이 position
은 mark가 있는 3 인덱스로 이동한다. mark가 없는 상태에서 reset ( ) 메소드를 호출하면 
InvalidMarkException 예외가 발생한다.
인덱스
Buffer
capacity
limit
position
mark
버퍼 처음으로 되돌아가기 위해 rewind( ) 메소드를 호출하면 다음 그림과 같이 limit은 변하지 않
지만 position은 0 인덱스로 다시 설정된다. mark는 position이나 limit이 mark보다 작은 값으
로 조정되면 자동으로 없어진다.
인덱스
Buffer
capacity
limit
position
rewind()
rewind( ) 대신 clear( ) 메소드를 호출하면 Buffer의 세 가지 속성은 초기화된다. limit은 capacity
로, position은 0으로 설정되고 mark는 자동으로 없어진다. 하지만 데이터는 삭제되지 않는다.</p>

<p>인덱스
Buffer
capacity
limit
position
clear()
compact( ) 메소드는 position에서 limit 사이의 데이터를 맨 앞으로 복사시키고 복사된 데이터 
다음 위치로 position을 이동시킨다. 예를 들어 다음과 같이 position이 3 인덱스 위치에 있을 때 
compact( )가 호출되면 3 인덱스와 4 인덱스 데이터는 0 인덱스와 1 인덱스로 복사되고 position
은 2 인덱스로 이동한다. 그리고 limit은 capacity로 이동한다. 0번과 1번 인덱스를 제외한 나머지 
인덱스의 데이터는 삭제되지 않고 남아있다.
capacity
compact()
a
b
c
d
e
limit
position
capacity
d
e
c
d
e
limit
position
compact( )를 호출하는 이유는 읽지 않은 데이터 뒤에 새로운 데이터를 저장하기 위해서이다.
버퍼 메소드
버퍼를 생성하고 사용하려면 버퍼가 제공하는 메소드를 잘 활용해야 한다. 버퍼들마다 공통으로 제
공하는 메소드들도 있고, 각 타입별로 제공되는 메소드들도 있다.</p>

<h3 id="1-공통-메소드">1) 공통 메소드</h3>

<p>모든 버퍼 클래스는 Buffer 추상 클래스를 상속하고 있기 때문에 Buffer 클래스에서 제공하는 메소
드는 모든 버퍼에서 사용할 수 있다. 위치 속성을 변경하는 flip( ), rewind( ), clear( ), mark( ), 
reset( ) 메소드는 모두 Buffer 추상 클래스가 제공한다. 
다음은 Buffer 추상 클래스가 가지고 있는 메소드를 정리한 표이다.</p>

<p>리턴 타입
메소드(매개변수)
설명
Object
array( )
버퍼가 래핑(wrap)한 배열을 리턴
int
arrayOffset( )
버퍼의 첫 번째 요소가 있는 내부 배열의 인덱스를 리턴
int
capacity( )
버퍼의 전체 크기를 리턴
Buffer
clear( )
버퍼의 위치 속성을 초기화(position=0, limit=capacity)
Buffer
flip( )
limit을 position으로, position을 0 인덱스로 이동
boolean
hasArray( )
버퍼가 래핑(wrap)한 배열을 가지고 있는지 여부
boolean
hasRemaining( )
position과 limit 사이에 요소가 있는지 여부
boolean
isDirect( )
운영체제의 버퍼를 사용하는지 여부
boolean
isReadOnly( )
버퍼가 읽기 전용인지 여부
int
limit( )
limit 위치를 리턴
Buffer
limit(int newLimit)
newLimit으로 limit 위치를 설정
Buffer
mark( )
현재 위치를 mark로 표시
int
position( )
position 위치를 리턴
Buffer
position(int newPosition)
newPosition으로 position 위치를 설정
int
remaining( )
position과 limit 사이의 요소의 개수
Buffer
reset( )
position을 mark 위치로 이동
Buffer
rewind( )
position을 0 인덱스로 이동</p>

<h3 id="2-데이터를-읽고-저장하는-메소드">2) 데이터를 읽고 저장하는 메소드</h3>

<p>버퍼에 데이터를 저장하는 메소드는 put( )이고, 데이터를 읽는 메소드는 get( )이다. 이 메소드들
은 Buffer 추상 클래스에는 없고 각 타입별 버퍼 클래스가 가지고 있다. 
get( )과 put( ) 메소드는 상대적Relative과 절대적Absolute으로 구분된다. position에서 데이터를 읽고 
저장할 경우는 상대적이고, position과 상관없이 주어진 인덱스에서 데이터를 읽고 저장하면 절대
적이다. 
다음은 ByteBuffer와 CharBuffer에서 제공하는 get( )과 put( ) 메소드이다. ShortBuffer, 
IntBuffer, LongBuffer, FloatBuffer, DoubleBuffer도 데이터 타입만 다를 뿐 비슷한 메소드
를 가지고 있다.</p>

<p>구분
ByteBuffer
CharBuffer
get( )
상대적 
get( )
get(byte[ ] dst)
get(byte[ ] dst, int offset, int length)
getChar( )
getDouble( )
getFloat( )
getInt( )
getLong( )
getShort( )
get( )
get(char[ ] dst)
get(char[ ] dst, int offset, int length)
절대적 
get(int index)
getChar(int index)
getDouble(int index)
getFloat(int index)
getInt(int index)
getLong(int index)
getShort(int index)
get(int index)
put( )
상대적 
put(byte b)
put(byte[ ] src)
put(byte[ ] src, int offset, int length)
put(ByteBuffer src)
putChar(char value)
putDouble(double value)
putFloat(float value)
putInt(int value)
putLong(long value)
putShort(short value)
put(char c)
put(char[ ] src)
put(char[ ] src, int offset, int length)
put(CharBuffer src)
put(String src)
put(String src, int start, int end)
절대적 
put(int index, byte b)
putChar(int index, char value)
putDouble(int index, double value)
putFloat(int index, float value)
putInt(int index, int value)
putLong(int index, long value)
putShort(int index, short value)
put(int index, char c)
상대적 메소드와 절대적 메소드를 쉽게 구분하는 방법은 다음과 같다. index 매개변수가 없으면 상대
적이고, index 매개변수가 있으면 절대적이다. 상대적 get( )과 put( ) 메소드를 호출하면 position
이 이동하지만, 절대적 get( )과 put( ) 메소드를 호출하면 position은 이동되지 않는다.</p>

<p>다음 예제는 데이터를 버퍼에 쓰고 읽기 위해 put( )과 get( ) 메소드를 호출할 때와 위치 속성을 변
경하는 메소드를 호출할 때 버퍼의 위치 속성의 변화를 보여준다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">sec03.exam02_buffer_method</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.Buffer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.ByteBuffer</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BufferMethodExample</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[7바이트 크기로 버퍼 생성]"</span><span class="o">);</span>
  <span class="nc">ByteBuffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nc">ByteBuffer</span><span class="o">.</span><span class="na">allocateDirect</span><span class="o">(</span><span class="mi">7</span><span class="o">);</span>
  <span class="n">printState</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
  
  <span class="n">buffer</span><span class="o">.</span><span class="na">put</span><span class="o">((</span><span class="kt">byte</span><span class="o">)</span><span class="mi">10</span><span class="o">);</span>
  <span class="n">buffer</span><span class="o">.</span><span class="na">put</span><span class="o">((</span><span class="kt">byte</span><span class="o">)</span><span class="mi">11</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[2바이트 저장 후]"</span><span class="o">);</span>
  <span class="n">printState</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
  
  <span class="n">buffer</span><span class="o">.</span><span class="na">put</span><span class="o">((</span><span class="kt">byte</span><span class="o">)</span><span class="mi">12</span><span class="o">);</span>
  <span class="n">buffer</span><span class="o">.</span><span class="na">put</span><span class="o">((</span><span class="kt">byte</span><span class="o">)</span><span class="mi">13</span><span class="o">);</span>
  <span class="n">buffer</span><span class="o">.</span><span class="na">put</span><span class="o">((</span><span class="kt">byte</span><span class="o">)</span><span class="mi">14</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[3바이트 저장 후]"</span><span class="o">);</span>
  <span class="n">printState</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
  
  <span class="n">buffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[flip() 실행 후]"</span><span class="o">);</span>
  <span class="n">printState</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
  
  <span class="n">buffer</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">3</span><span class="o">]);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[3바이트 읽은 후]"</span><span class="o">);</span>
  <span class="n">printState</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
  
  <span class="n">buffer</span><span class="o">.</span><span class="na">mark</span><span class="o">();</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"--------[현재 위치를 마크해놓음]"</span><span class="o">);</span>
  
  <span class="n">buffer</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">2</span><span class="o">]);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[2바이트 읽은 후]"</span><span class="o">);</span>
  <span class="n">printState</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
</code></pre></div></div>

<p>buffer.reset();
  System.out.println(“——–[position을 마크 위치로 ৤ӣ]”);
  printState(buffer);</p>

<p>buffer.rewind();
  System.out.println(“[rewind() 실행 후]”);
  printState(buffer);</p>

<p>buffer.clear();
  System.out.println(“[clear() 실행 후]”);
  printState(buffer);
 }</p>

<p>public static void printState(Buffer buffer) {
  System.out.print(“\tposition:” + buffer.position() + “, “);
  System.out.print(“\tlimit:” + buffer.limit() + “, “);
  System.out.println(“\tcapacity:” + buffer.capacity());
 }
}
실행 결과
[7바이트 크기로 버퍼 생성]
  position:0,  limit:7,  capacity:7
[2바이트 저장 후]
  position:2,  limit:7,  capacity:7
[3바이트 저장 후]
  position:5,  limit:7,  capacity:7
[flip() 실행 후]
  position:0,  limit:5,  capacity:7
[3바이트 읽은 후]
  position:3,  limit:5,  capacity:7
——–[현재 위치를 마크해놓음]
[2바이트 읽은 후]
  position:5,  limit:5,  capacity:7
——–[position을 마크 위치로 ৤ӣ]
  position:3,  limit:5,  capacity:7
[rewind() 실행 후]
  position:0,  limit:5,  capacity:7
[clear() 실행 후]
  position:0,  limit:7,  capacity:7</p>

<h3 id="3-버퍼-예외의-종류">3) 버퍼 예외의 종류</h3>

<p>버퍼가 데이터로 꽉 찼을 때 put( )으로 새 데이터를 저장하려고 하면 BufferOverflowException
이 발생한다. 그리고 버퍼에서 더 이상 읽을 데이터가 없을 때 get( )으로 데이터를 읽으려고 하면 
BufferUnderflowException이다. 다음은 버퍼 메소드에서 발생할 수 있는 예외들을 보여준다.
예외
설명
BufferOverflowException 
position이 limit에 도달했을 때 put( )을 호출하면 발생
BufferUnderflowException 
position이 limit에 도달했을 때 get( )을 호출하면 발생
InvalidMarkException
mark가 없는 상태에서 reset( ) 메소드를 호출하면 발생
ReadOnlyBufferException
읽기 전용 버퍼에서 put( ) 또는 compact( ) 메소드를 호출하면 발생
버퍼 변환
채널을 통해 데이터를 입출력할 때에는 반드시 ByteBuffer를 사용한다. 그렇기 때문에 문자열
이나 배열을 채널을 통해 출력하려면 ByteBuffer로 변환해야 한다. 그리고 채널을 통해 읽은 
ByteBuffer를 원래 타입으로 변환해서 사용해야 한다.</p>

<h3 id="1-string--bytebuffer">1) String ↔ ByteBuffer</h3>

<p>프로그램에서 가장 많이 처리되는 데이터는 문자열이다. 채널을 통해 문자열을 파일이나 네트워
크로 입출력하려면 특정 문자셋으로 문자열을 인코딩해서 ByteBuffer를 얻어야 하며, 반대로 
ByteBuffer를 디코딩해서 문자열로 복원해야 한다. 
특정 문자셋으로 인코딩과 디코딩을 하는 Charset은 다음 두 가지 방법으로 얻을 수 있다.
Charset charset = Charset.forName(“UTF-8”); //UTF-8로 인코딩 및 디코딩
Charset charset = Charset.defaultCharset(); //운영체제의 기본 문자셋으로 인코딩 및 디코딩
문자열을 ByteBuffer로 변환하려면 다음과 같이 Charset의 encode( ) 메소드를 호출하면 된다. 
String data = …;
ByteBuffer byteBuffer = charset.encode(data);</p>

<p>반대로 ByteBuffer를 문자열로 변환하려면 다음과 같이 decode( ) 메소드를 호출하면 된다. 
ByteBuffer byteBuffer = …;
String data = charset.decode(byteBuffer).toString();
다음 예제는 문자열을 UTF-8로 인코딩해서 ByteBuffer를 얻고, 다시 UTF-8로 디코딩해서 문자
열로 복원한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">sec03.exam03_convert_buffer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.ByteBuffer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.Charset</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ByteBufferToStringExample</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Charset</span> <span class="n">charset</span> <span class="o">=</span> <span class="nc">Charset</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">);</span>
  
  <span class="nc">String</span> <span class="n">data</span> <span class="o">=</span> <span class="s">"안֞하세요"</span><span class="o">;</span>
  
  <span class="c1">//문자열 -&gt; 인코딩 -&gt; ByteBuffer</span>
  <span class="nc">ByteBuffer</span> <span class="n">byteBuffer</span> <span class="o">=</span> <span class="n">charset</span><span class="o">.</span><span class="na">encode</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">byteBuffer</span><span class="o">);</span>
  
  <span class="c1">//ByteBuffer -&gt; 디코딩 -&gt; 문자열</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">charset</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">byteBuffer</span><span class="o">).</span><span class="na">toString</span><span class="o">();</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>실행 결과
java.nio.HeapByteBuffer[pos=0 lim=15 cap=23]
안֞하세요</p>

<h3 id="2-배열--bytebuffer">2) 배열 → ByteBuffer</h3>

<p>byte[ ], int[ ], double[ ] 배열을 ByteBuffer로 변환하는 방법을 알아보자. 
byte[ ] 배열을 ByteBuffer로 변환할 때에는 간단하게 wrap( ) 메소드를 이용하면 된다.
byte[] byteArray = { 10, 20 };
ByteBuffer byteBuffer = ByteBuffer.wrap(byteArray);
System.out.println(byteBuffer);
int[ ] 배열을 ByteBuffer로 변환하기 위해서는 int[ ]의 length보다 4배 큰 capacity를 가진 
ByteBuffer가 필요하다. 그 이유는 int 타입은 4byte 크기를 가지기 때문이다. 다음은 Int[ ] 배열
을 ByteBuffer로 변환하는 방법을 보여준다. 
int[] intArray = { 10, 20 };
ByteBuffer byteBuffer= ByteBuffer.allocate(intArray.length * 4);
byteBuffer.asIntBuffer().put(intArray);
ByteBuffer의 asIntBuffer( ) 메소드는 ByteBuffer의 IntBuffer 뷰를 리턴한다. 뷰view란 실제 값
을 가지지 않는 가상 객체이다. IntBuffer 뷰의 put( ) 메소드를 통해 int[ ]을 저장하면 실제 저장되는 
곳은 ByteBuffer이다. 다음은 ByteBuffer가 가지고 있는 타입별 버퍼 뷰를 제공하는 메소드들이다.
리턴 타입
변환 메소드
설명
ShorBuffer
asShortBuffer( )
2byte short으로 구성된 ShortBuffer 뷰를 리턴
IntBuffer
asIntBuffer( )
4byte int로 구성된 IntBuffer 뷰를 리턴
LongBuffer
asLongBuffer( )
8byte long으로 구성된 LongBuffer 뷰를 리턴
FloatBuffer
asFloatBuffer( )
4byte float으로 구성된 FloatBuffer 뷰를 리턴
DoubleBuffer
asDoubleBuffer( )
8byte double로 구성된 DoubleBuffer 뷰를 리턴
다음은 double[ ] 배열을 ByteBuffer로 변환하는 방법을 보여준다.
double[] doubleArray = { 10.0, 20.0 };
ByteBuffer byteBuffer= ByteBuffer.allocate(doubleArray.length * 8);
byteBuffer.asDoubleBuffer().put(doubleArray);</p>

<p>다음은 byte[ ], int[ ], double[ ] 배열을 ByteBuffer로 변환하는 방법을 보여준다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">sec03.exam03_convert_buffer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.ByteBuffer</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayToIntBufferExample</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
  <span class="c1">//byte[] -&gt; ByteBuffer</span>
  <span class="kt">byte</span><span class="o">[]</span> <span class="n">byteArray</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">};</span>
  <span class="nc">ByteBuffer</span> <span class="n">byteBuffer1</span> <span class="o">=</span> <span class="nc">ByteBuffer</span><span class="o">.</span><span class="na">wrap</span><span class="o">(</span><span class="n">byteArray</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">byteBuffer1</span><span class="o">);</span>
  
  <span class="c1">//int[] -&gt; ByteBuffer</span>
  <span class="kt">int</span><span class="o">[]</span> <span class="n">intArray</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span> <span class="o">};</span>
  <span class="nc">ByteBuffer</span> <span class="n">byteBuffer2</span><span class="o">=</span> <span class="nc">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="n">intArray</span><span class="o">.</span><span class="na">length</span> <span class="o">*</span> <span class="mi">4</span><span class="o">);</span>
  <span class="n">byteBuffer2</span><span class="o">.</span><span class="na">asIntBuffer</span><span class="o">().</span><span class="na">put</span><span class="o">(</span><span class="n">intArray</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">byteBuffer2</span><span class="o">);</span>
  
  <span class="c1">//int[] -&gt; ByteBuffer</span>
  <span class="kt">double</span><span class="o">[]</span> <span class="n">doubleArray</span> <span class="o">=</span> <span class="o">{</span> <span class="mf">10.0</span><span class="o">,</span> <span class="mf">20.0</span> <span class="o">};</span>
  <span class="nc">ByteBuffer</span> <span class="n">byteBuffer3</span><span class="o">=</span> <span class="nc">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="n">doubleArray</span><span class="o">.</span><span class="na">length</span> <span class="o">*</span> <span class="mi">8</span><span class="o">);</span>
  <span class="n">byteBuffer3</span><span class="o">.</span><span class="na">asDoubleBuffer</span><span class="o">().</span><span class="na">put</span><span class="o">(</span><span class="n">doubleArray</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">byteBuffer3</span><span class="o">);</span>
 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>실행 결과
java.nio.HeapByteBuffer[pos=0 lim=2 cap=2]
java.nio.HeapByteBuffer[pos=0 lim=8 cap=8]
java.nio.HeapByteBuffer[pos=0 lim=16 cap=16]</p>

<h3 id="3-bytebuffer--배열">3) ByteBuffer → 배열</h3>

<p>ByteBuffer에 데이터를 저장한 후, position이 0이고 limit이 마지막 데이터 다음 위치에 있을 때 
ByteBuffer를 배열로 변환하는 방법에 대해 알아보자.</p>

<p>ByteBuffer의 capacity까지 byte[ ] 배열로 얻으려면 array( ) 메소드를 사용할 수 있다. 
byte[] byteArray = byteBuffer.array();
ByteBuffer의 limit까지 byte[ ] 배열로 얻으려면 ByteBuffer limit 길이만큼 byte[ ] 배열을 생성
하고, get( ) 메소드를 이용해서 읽은 byte 값을 배열에 저장하면 된다. 
byteArray = new byte[byteBuffer.limit()];
byteBuffer.get(byteArray);
int[ ] 배열을 얻으려면 ByteBuffer의 IntBuffer 뷰 limit 길이만큼 int[ ] 배열을 생성하고, 
IntBuffer 뷰의 get( ) 메소드로 읽은 int 값을 배열에 저장하면 된다.
IntBuffer intBuffer = byteBuffer.asIntBuffer();
int[] intArray = new int[intBuffer.limit()];
intBuffer.get(intArray);  //IntBuffer ࠭를 통해 읽은 int 값을 배열에 저장
double[ ] 배열을 얻으려면 ByteBuffer의 DoubleBuffer 뷰 capacity 길이만큼 double[ ] 배열
을 생성한 뒤에, DoubleBuffer 뷰의 get( ) 메소드로 읽은 double 값을 배열에 저장하면 된다.
DoubleBuffer doubleBuffer = byteBuffer.asDoubleBuffer();
double[] doubleArray = new double[doubleBuffer.limit()];
doubleBuffer.get(doubleArray);  //DoubleBuffer ࠭를 통해 읽은 double 값을 배열에 저장
다음 예제는 ByteBuffer를 byte[ ], int[ ], double[ ] 배열로 변환하는 방법을 보여준다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">sec03.exam03_convert_buffer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.ByteBuffer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.DoubleBuffer</span><span class="o">;</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.nio.IntBuffer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ByteBufferToArrayExample</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
  <span class="c1">//ByteBuffer -&gt; byte[] ------------------------------------------</span>
  <span class="nc">ByteBuffer</span> <span class="n">byteBuffer1</span> <span class="o">=</span> <span class="nc">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
  <span class="kt">byte</span> <span class="n">b1</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span> <span class="n">byteBuffer1</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">b1</span><span class="o">);</span>
  <span class="kt">byte</span> <span class="n">b2</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span> <span class="n">byteBuffer1</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">b2</span><span class="o">);</span>
  <span class="n">byteBuffer1</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">byteBuffer1</span> <span class="o">+</span> <span class="s">" -&gt; "</span><span class="o">);</span>
  
  <span class="kt">byte</span><span class="o">[]</span> <span class="n">byteArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">byteBuffer1</span><span class="o">.</span><span class="na">limit</span><span class="o">()];</span>
  <span class="n">byteBuffer1</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">byteArray</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">byteArray</span><span class="o">));</span>
  
  <span class="c1">//ByteBuffer -&gt; int[] ---------------------------------------------</span>
  <span class="nc">ByteBuffer</span> <span class="n">byteBuffer2</span> <span class="o">=</span> <span class="nc">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="mi">16</span><span class="o">);</span>
  <span class="n">byteBuffer2</span><span class="o">.</span><span class="na">putInt</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
  <span class="n">byteBuffer2</span><span class="o">.</span><span class="na">putInt</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>
  <span class="n">byteBuffer2</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">byteBuffer2</span> <span class="o">+</span> <span class="s">" -&gt; "</span><span class="o">);</span>  
  
  <span class="nc">IntBuffer</span> <span class="n">intBuffer</span> <span class="o">=</span> <span class="n">byteBuffer2</span><span class="o">.</span><span class="na">asIntBuffer</span><span class="o">();</span>
  <span class="kt">int</span><span class="o">[]</span> <span class="n">intArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">intBuffer</span><span class="o">.</span><span class="na">capacity</span><span class="o">()];</span>
  <span class="n">intBuffer</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">intArray</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">intArray</span><span class="o">));</span>
  
  <span class="c1">//ByteBuffer -&gt; double[] ---------------------------------------</span>
  <span class="nc">ByteBuffer</span> <span class="n">byteBuffer3</span> <span class="o">=</span> <span class="nc">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="mi">24</span><span class="o">);</span>
  <span class="n">byteBuffer3</span><span class="o">.</span><span class="na">putDouble</span><span class="o">(</span><span class="mf">10.0</span><span class="o">);</span>
  <span class="n">byteBuffer3</span><span class="o">.</span><span class="na">putDouble</span><span class="o">(</span><span class="mf">20.0</span><span class="o">);</span>
  <span class="n">byteBuffer3</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">byteBuffer3</span> <span class="o">+</span> <span class="s">" -&gt; "</span><span class="o">);</span>  
  
  <span class="nc">DoubleBuffer</span> <span class="n">doubleBuffer</span> <span class="o">=</span> <span class="n">byteBuffer3</span><span class="o">.</span><span class="na">asDoubleBuffer</span><span class="o">();</span>
  <span class="kt">double</span><span class="o">[]</span> <span class="n">doubleArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">doubleBuffer</span><span class="o">.</span><span class="na">capacity</span><span class="o">()];</span>
  <span class="n">doubleBuffer</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">doubleArray</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">doubleArray</span><span class="o">));</span> 
 <span class="o">}</span>
<span class="o">}</span>


</code></pre></div></div>

<p><strong>실행 결과</strong></p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java.nio.HeapByteBuffer[pos=0 lim=2 cap=3] -&gt; [10, 20]
java.nio.HeapByteBuffer[pos=0 lim=8 cap=16] -&gt; [10, 20]
java.nio.HeapByteBuffer[pos=0 lim=16 cap=24] -&gt; [10.0, 20.0]

## 04. 파일 입출력

NIO에서 제공하는 파일 채널FileChannel을 이용하면 파일 읽기와 쓰기를 할 수 있다. 파일 채널은 동기
화 처리가 되어 있기 때문에 멀티 스레드 환경에서 사용해도 안전하다.
FileChannel
프로그램
버
퍼
입력
데이터
출력
데이터
파일
파일 채널
FileChannel은 정적 메소드인 open( )을 호출해서 얻을 수도 있지만, IO의 FileInputStream, 
FileOutputStream의 getChannel( ) 메소드를 호출해서 얻을 수도 있다. 다음은 open( ) 메소드
로 FileChannel을 얻는 방법을 보여준다.
FileChannel fileChannel = FileChannel.open(Path path, OpenOption... options);
첫 번째 매개값은 열고자 하는 파일의 Path 객체이고, 두 번째 매개값부터는 다음 표에 나와있는 
StandardOpenOption의 열거 상수를 나열해주면 된다.


열거 상수
설명
READ
읽기용으로 파일을 연다.
WRITE
쓰기용으로 파일을 연다.
CREATE
파일이 없다면 새 파일을 생성한다.
CREATE_NEW
새 파일을 만든다. 파일이 이미 있으면 예외와 함께 실패한다.
APPEND
파일 끝에 데이터를 추가한다(WRITE나 CREATE와 함께 사용됨).
DELETE_ON_CLOSE
스트림을 닫을 때 파일을 삭제한다(임시파일을 삭제할 때 사용).
TRUNCATE_EXISTING
파일을 0바이트로 잘라낸다(WRITE 옵션과 함께 사용됨).
예를 들어 ‘C:\Temp\file.txt’ 파일을 생성하고, 내용을 쓰고 싶다면 다음과 같이 매개값을 지정하
면 된다.
FileChannel fileChannel = FileChannel.open(
 Paths.get("C:/Temp/file.txt"),
 StandardOpenOption.CREATE_NEW,
 StandardOpenOption.WRITE
);
다음은 ‘C:\Temp\file.txt’ 파일을 읽고, 쓸 수 있도록 FileChannel을 생성한다.
FileChannel fileChannel = FileChannel.open(
 Paths.get("C:/Temp/file.txt"),
 StandardOpenOption.READ,
 StandardOpenOption.WRITE
);
FileChannel을 더 이상 이용하지 않을 경우에는 다음과 같이 close( ) 메소드를 호출해서 닫아주어
야 한다.
fileChannel.close();


파일 입출력
파일로 내용을 출력(저장)하려면 FileChannel의 write( ) 메소드를 호출하면 된다. 매개값으로 
ByteBuffer 객체를 주면 되는데, 파일에 쓰여지는 바이트는 ByteBuffer의 position부터 limit까
지이다. position이 0이고 limit이 capacity와 동일하다면 ByteBuffer의 모든 바이트가 파일에 
쓰여진다. write( ) 메소드의 리턴값은 ByteBuffer에서 실제로 파일로 출력된 바이트 수이다.
int byteNum = fileChannel.write(ByteBuffer buffer);
다음 예제는 FileChannel을 이용해서 문자열을 C:\Temp\file.txt 파일로 출력(저장)한다.

```java
package sec04.exam01_file_read_write;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
public class FileChannelWriteExample {
 public static void main(String[] args) throws IOException {
  //Path 생성과 디렉토리 생성
  Path path = Paths.get("C:/Temp/file.txt");
  Files.createDirectories(path.getParent());
  
  //FileChannel 열기
  FileChannel fileChannel = FileChannel.open(
   path, StandardOpenOption.CREATE, StandardOpenOption.WRITE);
  
  //문자열을 ByteBuffer로 변환
  String data = "안֞하세요";
  Charset charset = Charset.forName("UTF-8");
</code></pre></div></div>

<p>ByteBuffer byteBuffer = charset.encode(data);</p>

<p>//FileChannel을 통해 ByteBuffer 출력하기
  int byteCount = fileChannel.write(byteBuffer);
  System.out.println(“file.txt : “ + byteCount + “ bytes written”);</p>

<p>//FileChannel 닫기
  fileChannel.close();
 }
}
실행 결과
file.txt : 15 bytes written
파일에서 내용을 읽기 위해서는 FileChannel의 read( ) 메소드를 호출하면 된다. 매개값으로 
ByteBuffer를 주면, 파일에서 읽은 바이트가 position부터 저장된다. read( ) 메소드의 리턴값은 
파일에서 읽은 바이트 수이다. 한 번 읽을 수 있는 최대 바이트 수는 ByteBuffer의 capacity이다. 
더 이상 읽을 바이트가 없다면 read( ) 메소드는 -1을 리턴한다.
int byteNum = fileChannel.read(ByteBuffer buffer);
read( ) 메소드로 ByteBuffer에 바이트가 저장될 때마다 position이 1씩 증가하게 된다. 따라서 
ByteBuffer에 저장한 마지막 바이트의 위치는 position-1이다. 다음 예제는 이전 예제에서 생성
한 C:\Temp\file.txt 파일을 읽고 콘솔에 출력한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">sec04.exam01_file_read_write</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.ByteBuffer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.FileChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.Charset</span><span class="o">;</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.nio.file.Path</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.file.Paths</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.file.StandardOpenOption</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FileChannelReadExample</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
  <span class="c1">//Path 생성</span>
  <span class="nc">Path</span> <span class="n">path</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"C:/Temp/file.txt"</span><span class="o">);</span>
  <span class="c1">//FileChannel 열기</span>
  <span class="nc">FileChannel</span> <span class="n">fileChannel</span> <span class="o">=</span> <span class="nc">FileChannel</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="n">path</span><span class="o">,</span> 
 
    <span class="nc">StandardOpenOption</span><span class="o">.</span><span class="na">READ</span><span class="o">);</span>
  
  <span class="c1">//읽은 바이트가 저장될 ByteBuffer 생성</span>
  <span class="nc">ByteBuffer</span> <span class="n">byteBuffer</span> <span class="o">=</span> <span class="nc">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
  
  <span class="c1">//FileChannel로부터 입력받기</span>
  <span class="nc">Charset</span> <span class="n">charset</span> <span class="o">=</span> <span class="nc">Charset</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">);</span>
  <span class="nc">String</span> <span class="n">data</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
  <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
   <span class="kt">int</span> <span class="n">byteNum</span> <span class="o">=</span> <span class="n">fileChannel</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">byteBuffer</span><span class="o">);</span>
   <span class="k">if</span><span class="o">(</span><span class="n">byteNum</span> <span class="o">=</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
   <span class="n">byteBuffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>
   <span class="n">data</span> <span class="o">+=</span> <span class="n">charset</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">byteBuffer</span><span class="o">).</span><span class="na">toString</span><span class="o">();</span>
   <span class="n">byteBuffer</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
  <span class="o">}</span>
  
  <span class="c1">//FileChannel 닫기</span>
  <span class="n">fileChannel</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
  
  <span class="c1">//읽은 내용을 콘솔에 출력</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"file.txt : "</span> <span class="o">+</span> <span class="n">data</span><span class="o">);</span>
 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>실행 결과</strong></p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>file.txt : 안֞하세요


28라인에서 flip( )을 호출한 이유는 limit을 현재 position으로 설정하고 position을 0으로 설정
하기 위해서이다. 29라인은 position에서 limit까지 읽고 문자열로 변환한다. 30라인에서 clear( ) 
메소드는 position을 0으로 limit을 capacity로 설정해서 ByteBuffer를 초기화한다. 
파일 복사
파일 복사를 구현하기 위해서는 하나의 ByteBuffer를 사이에 두고 파일 읽기용 FileChannel과 
파일 쓰기용 FileChannel이 읽기와 쓰기를 교대로 번갈아 수행하도록 하면 된다.
FileChannel
FileChannel
프로그램
버퍼
타겟 파일
소스 파일
다음 예제는 FileChannel을 이용해서 이미지 파일을 복사한다. 다이렉트 버퍼를 사용하는데, 
FileChannel의 입출력 성능을 향상시키기 위해서이다. 

```java
package sec04.exam02_file_copy;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
public class FileCopyExample {
 public static void main(String[] args) throws IOException {
  //Path 생성
  Path from = Paths.get("src/sec04/exam02_file_copy/house.jpg");
  Path to = Paths.get("C:/Temp/house.jpg");
  
</code></pre></div></div>

<p>//입력용 FileChannel 열기
  FileChannel fileChannel_from = FileChannel.open(
   from, StandardOpenOption.READ);</p>

<p>//출력용 FileChannel 열기
  FileChannel fileChannel_to = FileChannel.open(
   to, StandardOpenOption.CREATE, StandardOpenOption.WRITE);</p>

<p>//다이렉트 ByteBuffer를 이용해서 데이터 입출력
  ByteBuffer buffer = ByteBuffer.allocateDirect(100);
  while(true) {
   int byteCount = fileChannel_from.read(buffer);
   if(byteCount = = -1) break;
   buffer.flip();
   fileChannel_to.write(buffer);
   buffer.clear();
  }</p>

<p>//FileChannel 닫기
  fileChannel_from.close();
  fileChannel_to.close();
  System.out.println(“파일 복사 성공”);
 }
}
실행 결과
파일 복사 성공
이번 예제처럼 ByteBuffer와 FileChannel 2개를 직접 생성해서 복사를 구현해도 좋지만, 단순히 
파일을 복사할 목적이라면 NIO의 Files 클래스의 copy( ) 메소드를 사용하는 것이 더 편리하다.
Files.copy(Path source, Path target, CopyOption… options);
첫 번째 source 매개값에는 원본 파일의 Path 객체를 지정하고 두 번째 target 매개값에는 타겟 파
일의 Path 객체를 지정하면 된다. 세 번째 매개값은 다음 세 가지 StandardCopyOption 열거 상
수를 목적에 맞게 나열해주면 된다.</p>

<p>열거 상수
설명
REPLACE_EXISTING
타겟 파일이 존재하면 대체한다.
COPY_ATTRIBUTES
파일 속성까지도 복사한다.
NOFOLLOW_LINKS
링크 파일일 경우 링크 파일만 복사하고 링크된 파일은 복사하지 않는다.
다음 예제는 Files 클래스의 copy( ) 메소드를 이용해서 이미지 파일을 복사한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">sec04.exam02_file_copy</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.file.Files</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.file.Path</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.file.Paths</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.file.StandardCopyOption</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FilesCopyMethodExample</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
  <span class="nc">Path</span> <span class="n">from</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"src/sec04/exam02_file_copy/house.jpg"</span><span class="o">);</span>
  <span class="nc">Path</span> <span class="n">to</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"C:/Temp/house.jpg"</span><span class="o">);</span>
  
  <span class="nc">Files</span><span class="o">.</span><span class="na">copy</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">to</span><span class="o">,</span> <span class="nc">StandardCopyOption</span><span class="o">.</span><span class="na">REPLACE_EXISTING</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"파일 복사 성공"</span><span class="o">);</span>
 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>실행 결과
파일 복사 성공</p>

<h2 id="05-파일-비동기-입출력">05. 파일 비동기 입출력</h2>

<p>FileChannel의 read( )와 write( ) 메소드는 파일 입출력 작업 동안 블로킹된다. UI 및 이벤트를 
처리하는 스레드에서 이 메소드들을 호출하면 블로킹되는 동안에 UI 갱신이나 이벤트 처리를 할 수 
없다. 따라서 별도의 작업 스레드를 생성해서 이 메소드들을 호출해야 한다.</p>

<p>NIO는 스레드풀을 이용해서 동시에 여러 개의 파일을 입출력할 수 있도록 비동기 파일 채널
(AsynchronousFileChannel)을 제공하고 있다. 비동기 파일 채널의 특징은 read( )와 write( ) 
메소드를 호출하면 스레드풀에게 입출력 처리를 요청하고 즉시 리턴된다는 점이다. 
입출력 처리는 스레드풀의 작업 스레드가 담당하는데, 작업 스레드가 입출력을 완료하게 되면 콜백
callback 메소드가 자동 호출된다. 따라서 입출력 완료 후 실행해야 할 코드가 있다면 콜백 메소드에 작
성하면 된다.
AsynchronousFileChannel
스레드풀
스레드 1
최
대
개
수
제
한
…
스레드 1
⑤ 작업 처리
스레드 2
각 스레드는 큐에서 작업을
가져와 실행시킴
스레드 n
⑤ 작업 처리
④ 작업 큐
① read()
② 즉시 리턴
⑥ 콜백 메소드 호출
① read()
② 즉시 리턴
⑥ 콜백 메소드 호출
③ 작업 처리
    요청
③ 작업 처리
    요청
스레드 2
비동기
채널1
비동기
채널2
파일 비동기 채널
AsynchronousFileChannel은 두 가지 정적 메소드인 open( )을 호출해서 얻을 수 있다. 첫 번
째 open( ) 메소드는 다음과 같이 파일의 Path와 열기 옵션을 매개값으로 받는다.
AsynchronousFileChannel fileChannel =  AsynchronousFileChannel.open(
 Path file, 
 OpenOption… options
);</p>

<p>이렇게 생성된 AsynchronousFileChannel은 내부적으로 생성되는 기본 스레드풀을 이용해서 스
레드를 관리한다. 기본 스레드풀의 최대 스레드 개수는 개발자가 지정할 수 없기 때문에 다음과 같이 
두 번째 open( ) 메소드로 AsynchronousFileChannel을 만들 수도 있다.
AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(
 Path file,
 Set&lt;? extends OpenOption&gt; options,
 ExecutorService executor,
 FileAttribute&lt;?&gt;… attrs
);
file 매개값은 파일의 Path이고, options 매개값은 열기 옵션이 저장된 Set이다. executor 매개값
은 스레드풀인 ExecutorService이다. attrs 매개값은 파일 생성 시 파일 속성이 될 FileAttribute
를 나열하면 된다. 
예로 ‘C:\Temp\file.txt’ 파일을 입출력할 수 있는 AsynchronousFileChannel은 다음과 같이 
생성할 수 있다.
ExecutorService executorService = Executors.newFixedThreadPool(
 Runtime.getRuntime().availableProcessors()
);
AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(
 Paths.get(“C:/Temp/file.txt”),
 EnumSet.of(StandardOpenOption.CREATE, StandardOpenOption.WRITE),
 executorService
);
Runtime.getRuntime( ).availableProcessors( )는 CPU의 코어 수를 리턴한다. 쿼드 코어 CPU
일 경우는 4를 리턴, 하이퍼 스레딩일 경우는 8을 리턴한다. EnumSet.of( ) 메소드는 매개값으로 
나열된 열거 상수를 Set 객체에 담아 리턴한다. AsynchronousFileChannel을 더 이상 사용하지 
않을 경우에는 다음과 같이 close( ) 메소드를 호출해서 닫아준다.
fileChannel.close();</p>

<p>파일 입출력
AsynchronousFileChannel이 생성되었다면 read( ), write( ) 메소드를 이용해서 입출력할 수 
있다.
read(
 ByteBuffer dst, 
 long position, 
 A attachment, 
 CompletionHandler&lt;Integer, A&gt; handler
);
write(
 ByteBuffer src, 
 long position, 
 A attachment, 
 CompletionHandler&lt;Integer, A&gt; handler
);
이 메소드들을 호출하면 즉시 리턴되고, 스레드풀의 스레드가 입출력 작업을 진행한다. dst와 src 매
개값은 읽거나 쓰기 위한 ByteBuffer이고, position 매개값은 파일에서 읽을 위치이거나 쓸 위치
이다. 파일의 첫 번째 바이트부터 읽거나 첫 번째 위치에 바이트를 쓰고 싶다면 position을 0으로 
주면 된다. 
attachment 매개값은 입출력 연산에 사용될 수 있는 첨부 객체이다. 첨부 객체는 콜백 메소드에서
도 사용할 수 있는데, 주로 입출력 후의 정보를 얻고자 할 때 사용된다. 만약 첨부 객체가 필요 없다
면 null을 대입해도 된다.
handler 매개값은 CompletionHandler&lt;Integer, A&gt; 구현 객체이다. Integer는 입출력 작업의 
결과 타입으로, read( )와 write( )가 읽거나 쓴 바이트 수이다. A는 첨부 객체 타입으로 개발자가 
CompletionHandler 구현 클래스를 작성할 때 임의로 지정이 가능하다. attachment가 null일 
경우, A는 Void로 해야 한다. 
CompletionHandler&lt;Integer, A&gt; 구현 객체는 비동기 작업이 정상적으로 완료된 경우와 예외 발
생으로 실패된 경우에 자동으로 콜백되는 다음 두 가지 메소드를 재정의해야 한다.</p>

<p>리턴 타입
메소드명(매개변수)
설명
void
completed(Integer result, A attachment)
작업이 정상적으로 완료된 경우 콜백
void
failed(Throwable exc, A attachment)
예외 때문에 작업이 실패된 경우 콜백
completed( ) 메소드의 result 매개값은 작업 결과가 대입되는데, read( )와 write( ) 작업 결과
는 읽거나 쓴 바이트 수이다. attachment 매개값은 read( )와 write( ) 호출 시 제공된 첨부 객체
이다. 
failed( ) 메소드의 exc 매개값은 작업 처리 도중 발생한 예외이다. 주목할 점은 콜백 메소드를 실
행하는 스레드는 read( )와 write( )를 호출한 스레드가 아니고 스레드풀의 작업 스레드라는 것이다. 
그렇기 때문에 JavaFX 또는 Swing 애플리케이션에서 UI 생성 및 변경 작업을 이 메소드에서 직접 
할 수 없고 Platform.runLater( ) 또는 SwingUtilities.invokeLater( )를 사용해야 한다.
다음은 CompletionHandler 구현 클래스를 작성하는 방법을 보여준다.
new CompletionHandler&lt;Integer, A&gt;() {
    @Override
    public void completed(Integer result, A attachment) { … }
    @Override
    public void failed(Throwable exc, A attachment) { … }
};
다음은 AsynchronousFileChannel을 이용해서 비동기적으로 ‘C:\Temp’ 디렉토리에 file0.txt 
~ file9.txt까지 총 10개의 파일을 생성한 후 ‘안녕하세요’라는 내용을 쓴다. 그리고 비동기 작업이 
완료되었을 때 출력된 바이트 수와 처리를 담당했던 스레드 이름을 콘솔에 출력한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">sec05</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.ByteBuffer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.AsynchronousFileChannel</span><span class="o">;</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.nio.channels.CompletionHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.Charset</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.file.Files</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.file.Path</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.file.Paths</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.file.StandardOpenOption</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.EnumSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.ExecutorService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.Executors</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AsynchronousFileChannelWriteExample</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
  <span class="c1">//스레드풀 생성</span>
  <span class="nc">ExecutorService</span> <span class="n">executorService</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
   <span class="nc">Path</span> <span class="n">path</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"C:/Temp/file"</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">".txt"</span><span class="o">);</span>
   <span class="nc">Files</span><span class="o">.</span><span class="na">createDirectories</span><span class="o">(</span><span class="n">path</span><span class="o">.</span><span class="na">getParent</span><span class="o">());</span>
   <span class="c1">//비동기 파일 채널 생성</span>
   <span class="nc">AsynchronousFileChannel</span> <span class="n">fileChannel</span> <span class="o">=</span> <span class="nc">AsynchronousFileChannel</span><span class="o">.</span><span class="na">open</span><span class="o">(</span>
    <span class="n">path</span><span class="o">,</span>
    <span class="nc">EnumSet</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="nc">StandardOpenOption</span><span class="o">.</span><span class="na">CREATE</span><span class="o">,</span> <span class="nc">StandardOpenOption</span><span class="o">.</span><span class="na">WRITE</span><span class="o">),</span> 
    <span class="n">executorService</span>
   <span class="o">);</span>
   <span class="nc">Charset</span> <span class="n">charset</span> <span class="o">=</span> <span class="nc">Charset</span><span class="o">.</span><span class="na">defaultCharset</span><span class="o">();</span>
   <span class="nc">ByteBuffer</span> <span class="n">byteBuffer</span> <span class="o">=</span> <span class="n">charset</span><span class="o">.</span><span class="na">encode</span><span class="o">(</span><span class="s">"안֞하세요"</span><span class="o">);</span>
   <span class="c1">//첨부 객체 생성</span>
   <span class="kd">class</span> <span class="nc">Attachment</span> <span class="o">{</span>
    <span class="nc">Path</span> <span class="n">path</span><span class="o">;</span>
    <span class="nc">AsynchronousFileChannel</span> <span class="n">fileChannel</span><span class="o">;</span>
   <span class="o">}</span>
   <span class="nc">Attachment</span> <span class="n">attachment</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Attachment</span><span class="o">();</span>
   <span class="n">attachment</span><span class="o">.</span><span class="na">path</span> <span class="o">=</span> <span class="n">path</span><span class="o">;</span>
   <span class="n">attachment</span><span class="o">.</span><span class="na">fileChannel</span> <span class="o">=</span> <span class="n">fileChannel</span><span class="o">;</span>
   <span class="c1">//CompletionHandler 객체 생성</span>
   <span class="nc">CompletionHandler</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Attachment</span><span class="o">&gt;</span> <span class="n">completionHandler</span> <span class="o">=</span> 


    <span class="k">new</span> <span class="nc">CompletionHandler</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Attachment</span><span class="o">&gt;()</span> <span class="o">{</span>
     <span class="nd">@Override</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">completed</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">result</span><span class="o">,</span> <span class="nc">Attachment</span> <span class="n">attachment</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
       <span class="n">attachment</span><span class="o">.</span><span class="na">path</span><span class="o">.</span><span class="na">getFileName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" : "</span> <span class="o">+</span> 
       <span class="n">result</span> <span class="o">+</span> <span class="s">" bytes written : "</span> <span class="o">+</span> 
       <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
      <span class="k">try</span> <span class="o">{</span>
       <span class="n">attachment</span><span class="o">.</span><span class="na">fileChannel</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="o">}</span>
     <span class="o">}</span>
 
     <span class="nd">@Override</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">failed</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">exc</span><span class="o">,</span> <span class="nc">Attachment</span> <span class="n">attachment</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">exc</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
      <span class="k">try</span> <span class="o">{</span>
       <span class="n">attachment</span><span class="o">.</span><span class="na">fileChannel</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="o">}</span>
     <span class="o">}</span>
   <span class="o">};</span>
   <span class="c1">//ByteBuffer에 있는 내용을 파일에 출력</span>
   <span class="n">fileChannel</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">byteBuffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">attachment</span><span class="o">,</span> <span class="n">completionHandler</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="c1">//스레드풀 종료</span>
  <span class="n">executorService</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>실행 결과</strong></p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>file0.txt : 15 bytes written : pool-1-thread-1
file2.txt : 15 bytes written : pool-1-thread-3
file1.txt : 15 bytes written : pool-1-thread-2
file3.txt : 15 bytes written : pool-1-thread-3
file4.txt : 15 bytes written : pool-1-thread-1
file5.txt : 15 bytes written : pool-1-thread-3
file6.txt : 15 bytes written : pool-1-thread-2


file7.txt : 15 bytes written : pool-1-thread-1
file8.txt : 15 bytes written : pool-1-thread-3
file9.txt : 15 bytes written : pool-1-thread-2
이 예제에서 주의할 점은 70라인에서 write( ) 메소드가 즉시 리턴되더라도 뒤에서는 작업 스레드
가 파일 쓰기 작업을 하고 있기 때문에 바로 AsynchronousFileChannel을 닫으면 안 된다. 작업
이 정상적으로 완료되었거나 실패일 경우 채널을 닫아야 하므로 completed( )와 failed( ) 메소드
에서 AsynchronousFileChannel의 close( )를 호출해야 한다. 
다음 예제는 이전 예제에서 생성한 file0.txt ~ file9.txt를 읽고 콘솔에 출력한다.

```java
package sec05;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousFileChannel;
import java.nio.channels.CompletionHandler;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.EnumSet;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
public class AsynchronousFileChannelReadExample {
 public static void main(String[] args) throws Exception {
  //스레드풀 생성
  ExecutorService executorService = Executors.newFixedThreadPool(3);
  for (int i = 0; i &lt; 10; i++) {
   Path path = Paths.get("C:/Temp/file" + i + ".txt");
   //비동기 파일 채널 생성
   AsynchronousFileChannel fileChannel = AsynchronousFileChannel.
 
     open(path,
     EnumSet.of(StandardOpenOption.READ), executorService);
</code></pre></div></div>

<p>ByteBuffer byteBuffer = ByteBuffer.allocate((int) fileChannel.size());
   //첨부 객체 생성</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="kd">class</span> <span class="nc">Attachment</span> <span class="o">{</span>
    <span class="nc">Path</span> <span class="n">path</span><span class="o">;</span>
    <span class="nc">AsynchronousFileChannel</span> <span class="n">fileChannel</span><span class="o">;</span>
    <span class="nc">ByteBuffer</span> <span class="n">byteBuffer</span><span class="o">;</span>
   <span class="o">}</span>
   <span class="nc">Attachment</span> <span class="n">attachment</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Attachment</span><span class="o">();</span>
   <span class="n">attachment</span><span class="o">.</span><span class="na">path</span> <span class="o">=</span> <span class="n">path</span><span class="o">;</span>
   <span class="n">attachment</span><span class="o">.</span><span class="na">fileChannel</span> <span class="o">=</span> <span class="n">fileChannel</span><span class="o">;</span>
   <span class="n">attachment</span><span class="o">.</span><span class="na">byteBuffer</span> <span class="o">=</span> <span class="n">byteBuffer</span><span class="o">;</span>
   <span class="c1">//CompletionHandler 객체 생성</span>
   <span class="nc">CompletionHandler</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Attachment</span><span class="o">&gt;</span> <span class="n">completionHandlernew</span> <span class="o">=</span> 
    <span class="k">new</span> <span class="nc">CompletionHandler</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Attachment</span><span class="o">&gt;()</span> <span class="o">{</span>
     <span class="nd">@Override</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">completed</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">result</span><span class="o">,</span> <span class="nc">Attachment</span> <span class="n">attachment</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">attachment</span><span class="o">.</span><span class="na">byteBuffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>
 
      <span class="nc">Charset</span> <span class="n">charset</span> <span class="o">=</span> <span class="nc">Charset</span><span class="o">.</span><span class="na">defaultCharset</span><span class="o">();</span>
      <span class="nc">String</span> <span class="n">data</span> <span class="o">=</span> <span class="n">charset</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">attachment</span><span class="o">.</span><span class="na">byteBuffer</span><span class="o">).</span><span class="na">toString</span><span class="o">();</span>
 
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
        <span class="n">attachment</span><span class="o">.</span><span class="na">path</span><span class="o">.</span><span class="na">getFileName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" : "</span> <span class="o">+</span> 
        <span class="n">data</span> <span class="o">+</span> <span class="s">" : "</span> <span class="o">+</span> 
        <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
      <span class="k">try</span> <span class="o">{</span>
       <span class="n">fileChannel</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
       <span class="c1">//e.printStackTrace();</span>
      <span class="o">}</span>
     <span class="o">}</span>
 
     <span class="nd">@Override</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">failed</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">exc</span><span class="o">,</span> <span class="nc">Attachment</span> <span class="n">attachment</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">exc</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
      <span class="k">try</span> <span class="o">{</span>
       <span class="n">fileChannel</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>


      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="o">}</span>
     <span class="o">}</span>
   <span class="o">};</span>
   <span class="c1">//파일을 읽고 ByteBuffer에 저장</span>
   <span class="n">fileChannel</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">byteBuffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">attachment</span><span class="o">,</span> <span class="n">completionHandlernew</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="c1">//스레드풀 종료</span>
  <span class="n">executorService</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>실행 결과</strong></p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>file1.txt : 안֞하세요 : pool-1-thread-2
file3.txt : 안֞하세요 : pool-1-thread-2
file4.txt : 안֞하세요 : pool-1-thread-2
file0.txt : 안֞하세요 : pool-1-thread-1
file2.txt : 안֞하세요 : pool-1-thread-3
file5.txt : 안֞하세요 : pool-1-thread-2
file6.txt : 안֞하세요 : pool-1-thread-1
file8.txt : 안֞하세요 : pool-1-thread-2
file7.txt : 안֞하세요 : pool-1-thread-3
이 예제에서도 72라인의 read( ) 메소드가 즉시 리턴되더라도 뒤에서는 작업 스레드가 파일 읽
기 작업을 하고 있기 때문에 바로 AsynchronousFileChannel을 닫으면 안 된다. 작업이 정상
적으로 완료되었거나 실패일 경우 채널을 닫아야 하므로 completed( )와 failed( ) 메소드에서 
AsynchronousFileChannel의 close( )를 호출해야 한다.

## 06. TCP 네트워크 입출력

NIO를 이용해서 TCP 서버/클라이언트 애플리케이션을 개발하는 방법을 알아보자. TCP
를 사용해서 네트워크 통신을 하려면 서버 소켓 채널(ServerSocketChannel )과 소켓 채널
(SocketChannel)을 알아야 한다.


ServerSocketChannel과 SocketChannel은 각각 IO의 ServerSocket과 Socket에 대응되는 
클래스이다. IO는 버퍼를 사용하지 않고 입출력한다면 이들 클래스는 버퍼를 이용해서 입출력한다. 
사용 방법은 IO와 큰 차이점이 없는데, 다음 그림처럼 ServerSocketChannel은 연결 요청을 수락
하고 통신용 SocketChannel을 생성한다
SocketChannel
입력
데이터
출력
데이터
SocketChannel
입력
데이터
출력
데이터
③ 통신(read, write)
② 연결 수락(accept) 후 SocketChannel 생성 
① 연결 요청(connect)
버
퍼
버
퍼
ServerSocketChannel
서버 소켓 채널
TCP 서버를 개발하려면 먼저 ServerSocketChannel을 생성해야 한다. ServerSocketChannel
은 정적 메소드인 open( )으로 생성한다. 그리고 포트(port)에 바인딩하기 위해 InetSocketAddress 
객체를 매개값으로 해서 bind( ) 메소드를 호출한다. 
ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
serverSocketChannel.bind(new InetSocketAddress(50001));
포트 바인딩까지 끝났다면 클라이언트 연결 수락을 위해 accept( ) 메소드를 실행한다. accept( ) 
메소드는 연결 요청이 들어오기 전까지 대기(블로킹)되고, 연결 요청이 들어오면 클라이언트와 통
신할 SocketChannel을 만들고 리턴한다.
SocketChannel socketChannel = serverSocketChannel.accept();


연결된 클라이언트의 IP와 포트 정보를 알고 싶다면 SocketChannel의 getRemoteAddress( ) 
메소드를 호출해서 SocketAddress를 얻으면 된다. 실제 리턴되는 것은 InetSocketAddress 인
스턴스이므로 다음과 같이 타입 변환할 수 있다.
InetSocketAddress socketAddress = (InetSocketAddress) socketChannel.
getRemoteAddress();
InetSocketAddress에는 다음과 같이 IP와 포트 정보를 리턴하는 메소드들이 있다.
리턴 타입
메소드명(매개변수)
설명
String
getHostName( )
클라이언트 IP 리턴
int
getPort( )
클라이언트 포트 번호 리턴
String 
toString( )
“IP:포트번호” 형태의 문자열 리턴
더 이상 클라이언트를 위해 연결 수락이 필요 없다면 ServerSocketChannel의 close( ) 메소드를 
호출해서 포트를 언바인딩시켜야 한다. 그래야 다른 프로그램에서 해당 포트를 재사용할 수 있다.
serverSocketChannel.close();
다음 예제는 반복적으로 accept( ) 메소드를 호출해서 복수의 클라이언트 연결을 수락하는 가장 기
본적인 TCP 서버 코드를 보여준다.

```java
package sec06.exam01_tcpchannel;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
public class ServerExample {
 public static void main(String[] args) {
</code></pre></div></div>

<p>//ServerSocketChannel 변수 선언
  ServerSocketChannel serverSocketChannel = null;
  try {
  //ServerSocketChannel 열기
   serverSocketChannel = ServerSocketChannel.open();
   //ServerSocketChannel 포트 바인딩
   serverSocketChannel.bind(new InetSocketAddress(50001));
   System.out.println(“[서버 시작]”);</p>

<p>//클라이언트의 연결 요청을 수락
   while (true) {
    SocketChannel socketChannel = serverSocketChannel.accept();
    InetSocketAddress isa = (InetSocketAddress) socketChannel.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  getRemoteAddress();
System.out.println(isa.getHostName() + " 연결 수락");
//연결 끊기
System.out.println(isa.getHostName() + " 연결 끊기");
socketChannel.close(); 
</code></pre></div></div>

<p>}
  } catch (Exception e) {
   e.printStackTrace();
  } finally {
   //ServerSocketChannel 닫기
   try {
    serverSocketChannel.close();
   } catch (IOException e1) {}
  }
 }
}
실행 결과
[서버 시작]
[연결 기다림]만 출력되고, 클라이언트의 연결 요청이 있을 때까지 accept( ) 메소드에서 블로킹(대
기) 상태가 된다. 실행을 종료하지 말고, 이어서 나오는 소켓 채널 생성을 학습하고 클라이언트 연결 
요청 예제를 실행시켜보자.</p>

<p>소켓 채널
TCP 클라이언트를 개발하려면 먼저 SocketChannel을 생성해야 한다. SocketChannel은 정적 
메소드인 open( )으로 생성한다. 서버 연결 요청은 connect( ) 메소드를 호출하면 되는데, 서버 IP
와 포트 정보를 가진 InetSocketAddress 객체를 매개값으로 주면 된다.
connect( ) 메소드는 연결이 완료될 때까지 블로킹(대기) 상태가 되고, 연결이 완료되면 리턴된다. 
다음은 로컬 PC의 50001 포트에 바인딩된 서버로 연결을 요청하는 코드이다.
SocketChannel socketChannel = SocketChannel.open();
socketChannel.connect(new InetSocketAddress(“localhost”, 50001));
connect( ) 메소드는 서버와 연결이 될 때까지 블로킹된다. 연결된 후, 클라이언트 프로그램을 종료
하거나 필요에 따라서 연결을 끊고 싶다면 다음과 같이 SocketChannel의 close( ) 메소드를 호출
하면 된다.
socketChannel.close();
다음 예제는 이전 예제에서 실행 중인 TCP 서버로 연결 요청하는 코드이다. connect( ) 메소드가 
정상적으로 리턴되면 연결 성공한 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">sec06.exam01_tcpchannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.InetSocketAddress</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.SocketChannel</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClientExample</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">//SocketChannel 변수 선언</span>
  <span class="nc">SocketChannel</span> <span class="n">socketChannel</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</code></pre></div></div>

<p>try {
   //SocketChannel 열기
   socketChannel = SocketChannel.open();
   //로컬 PC의 50001에서 실행 중인 ServerSocketChannel로 연결 요청
   System.out.println(“[연결 요청]”);
   socketChannel.connect(new InetSocketAddress(“localhost”, 50001));
   System.out.println(“[연결 성공]”);
  } catch (Exception e) {
   e.printStackTrace();
  } finally {
   //SocketChannel 닫기
   try {
    System.out.println(“[연결 끊기]”);
    socketChannel.close();
   } catch (IOException e1) {}
  }
 }
}
실행 결과
ClientExample.java
ServerExample.java
[연결 요청]
[연결 성공]
[연결 끊기]
[서버 시작]
127.0.0.1 연결 수락
127.0.0.1 연결 끊기</p>

<p>네트워크 입출력
클라이언트가 연결 요청(connect ( ) )하고 서버가 연결 수락(accept ( ) )했다면, 양쪽 
SocketChannel 객체의 read( ), write( ) 메소드를 호출해서 네트워크 입출력을 할 수 있다. 이 메
소드들은 모두 버퍼를 이용한다.</p>

<p>SocketChannel
입력
데이터
출력
데이터
SocketChannel
입력
데이터
출력
데이터
통신(read, write)
버
퍼
버
퍼
다음은 SocketChannel의 write( ) 메소드를 이용해서 문자열을 보내는 코드이다.
Charset charset = Charset.forName(“UTF-8”);
ByteBuffer byteBuffer = charset.encode(“Hello Server”);
socketChannel.write(byteBuffer);
다음은 SocketChannel의 read( ) 메소드를 이용해서 문자열을 받는 코드이다.
ByteBuffer byteBuffer = ByteBuffer.allocate(100);
int byteNum = socketChannel.read(byteBuffer);
byteBuffer.flip();
Charset charset = Charset.forName(“UTF-8”);
String message = charset.decode(byteBuffer).toString();
다음 예제에서는 연결 성공 후 클라이언트가 ‘Hello Server’를 서버로 보내면 서버가 응답으로 
‘Hello Client’를 클라이언트로 보낸다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">sec06.exam02_data_read_write</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.InetSocketAddress</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.ByteBuffer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.ServerSocketChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.SocketChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.Charset</span><span class="o">;</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServerExample</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">//ServerSocketChannel 변수 선언</span>
  <span class="nc">ServerSocketChannel</span> <span class="n">serverSocketChannel</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="k">try</span> <span class="o">{</span>
   <span class="c1">//ServerSocketChannel 열기</span>
   <span class="n">serverSocketChannel</span> <span class="o">=</span> <span class="nc">ServerSocketChannel</span><span class="o">.</span><span class="na">open</span><span class="o">();</span>
   <span class="c1">//ServerSocketChannel 포트 바인딩</span>
   <span class="n">serverSocketChannel</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="k">new</span> <span class="nc">InetSocketAddress</span><span class="o">(</span><span class="mi">50001</span><span class="o">));</span>
   
   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[서버 시작]"</span><span class="o">);</span>
   <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//클라이언트의 연결 요청을 수락</span>
    <span class="nc">SocketChannel</span> <span class="n">socketChannel</span> <span class="o">=</span> <span class="n">serverSocketChannel</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>
    <span class="nc">InetSocketAddress</span> <span class="n">isa</span> <span class="o">=</span> <span class="o">(</span><span class="nc">InetSocketAddress</span><span class="o">)</span> 
 
      <span class="n">socketChannel</span><span class="o">.</span><span class="na">getRemoteAddress</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isa</span><span class="o">.</span><span class="na">getHostName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" 연결 수락"</span><span class="o">);</span>
    <span class="nc">ByteBuffer</span> <span class="n">byteBuffer</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">Charset</span> <span class="n">charset</span> <span class="o">=</span> <span class="nc">Charset</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">);</span>
    <span class="c1">//클라이언트가 보մ 데이터 받기</span>
    <span class="n">byteBuffer</span> <span class="o">=</span> <span class="nc">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">byteNum</span> <span class="o">=</span> <span class="n">socketChannel</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">byteBuffer</span><span class="o">);</span>
    <span class="n">byteBuffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>
    <span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="n">charset</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">byteBuffer</span><span class="o">).</span><span class="na">toString</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isa</span><span class="o">.</span><span class="na">getHostName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" 데이터 받기: "</span> <span class="o">+</span> <span class="n">message</span><span class="o">);</span>
    <span class="c1">//클라이언트로 데이터 보내기</span>
    <span class="n">byteBuffer</span> <span class="o">=</span> <span class="n">charset</span><span class="o">.</span><span class="na">encode</span><span class="o">(</span><span class="s">"Hello Client"</span><span class="o">);</span>
    <span class="n">socketChannel</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">byteBuffer</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isa</span><span class="o">.</span><span class="na">getHostName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" 데이터 보냄"</span><span class="o">);</span>
    
    <span class="c1">//연결 끊기</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isa</span><span class="o">.</span><span class="na">getHostName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" 연결 끊기"</span><span class="o">);</span>
    <span class="n">socketChannel</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>


   <span class="o">}</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
  <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
   <span class="c1">//ServerSocketChannel 닫기</span>
   <span class="k">try</span> <span class="o">{</span>
    <span class="n">serverSocketChannel</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
   <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e1</span><span class="o">)</span> <span class="o">{</span>
   <span class="o">}</span>
  <span class="o">}</span>
 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>실행 결과</strong></p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[서버 시작]

```java
package sec06.exam02_data_read_write;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;
public class ClientExample {
 public static void main(String[] args) {
  //SocketChannel 변수 선언
  SocketChannel socketChannel = null;
  try {
   //SocketChannel 열기
   socketChannel = SocketChannel.open();
   //로컬 PC의 50001에서 실행 중인 ServerSocketChannel로 연결 요청
   System.out.println("[연결 요청]");
</code></pre></div></div>

<p>socketChannel.connect(new InetSocketAddress(“localhost”, 50001));
   System.out.println(“[연결 성공]”);
   ByteBuffer byteBuffer = null;
   Charset charset = Charset.forName(“UTF-8”);
   //서버로 데이터 보내기
   byteBuffer = charset.encode(“Hello Server”);
   socketChannel.write(byteBuffer);
   System.out.println(“서버로 데이터 보냄”);
   //서버가 보մ 데이터 받기
   byteBuffer = ByteBuffer.allocate(100);
   int byteNum = socketChannel.read(byteBuffer);
   byteBuffer.flip();
   String message = charset.decode(byteBuffer).toString();
   System.out.println(“서버에서 데이터 받기: “ + message);
  } catch (Exception e) {
   e.printStackTrace();
  } finally {
   //SocketChannel 닫기
   try {
    System.out.println(“[연결 끊기]”);
    socketChannel.close();
   } catch (IOException e1) {
   }
  }
 }
}
실행 결과
ClientExample.java
ServerExample.java
[연결 요청]
[연결 성공]
데이터 보냄
데이터 받기: Hello Client
[연결 끊기]
[서버 시작]
127.0.0.1 연결 수락
127.0.0.1 데이터 받기: Hello Server
127.0.0.1 데이터 보냄
127.0.0.1 연결 끊기</p>

<p>데이터를 받기 위해 read( ) 메소드를 호출하면 상대방이 데이터를 보내기 전까지는 블로킹(대기)
상태가 된다. read( ) 메소드가 블로킹 상태에서 해제되고 리턴되는 경우는 다음 세 가지이다.
블로킹이 해제되는 경우
리턴값
상대방이 데이터를 보냄
읽은 바이트 수
상대방이 정상적으로 SocketChannel의 close( )를 호출
-1
상대방이 비정상적으로 종료
IOException 발생
상대방이 정상적으로 SocketChannel의 close( )를 호출하고 연결을 끊었을 경우와 상대방이 비
정상적으로 종료된 경우는 예외 처리를 해서 SocketChannel을 닫기 위해 close( ) 메소드를 호출
하는 것이 좋다.
try {
 …
 //상대방이 비정상적으로 종료했을 경우 IOException 발생
 int byteNum = socketChannel.read(byteBuffer);</p>

<p>//상대방이 정상적으로 SocketChannel의 close()를 호출했을 경우
 if(byteNum= = -1) {
 throw new IOException();  //강제로 IOException 발생시ఇ
 }
 …
} catch (Exception e) {
 …
} finally {
 //연결 끊기
 try { socketChannel.close(); } catch(Exception e2) { }
}
스레드 병렬 처리
TCP 채널을 이용할 경우 데이터 입출력이 완료되기 전까지 read( )와 write( ) 메소드는 블로킹된
다. 따라서 서버가 동시에 여러 클라이언트와 통신을 하기 위해서는 멀티 스레드를 이용해서 병렬 처
리해야 한다.</p>

<p>서버
accept()
② 스레드 생성 
③ 처리 요청 
① 연결 요청
⑤ 응답
SocketChannel
④ 작업 처리
(SocketChannel 생성) 
(SocketChannel 생성) 
작업 스레드 1
② 스레드 생성 
③ 처리 요청 
① 연결 요청
⑤ 응답
SocketChannel
④ 작업 처리
작업 스레드 2
클라이언트 1
(SocketChannel)
클라이언트 2
(SocketChannel)
위 그림과 같이 클라이언트별로 스레드를 생성해서 병렬 처리를 한다면 클라이언트의 폭증이 있을 
때 과도한 스레드가 생성되어 서버 성능이 급격히 저하된다. 좋은 해결 방법은 서버에서 스레드풀을 
사용해서 병렬 처리하는 것이다.
서버
스레드풀(ExecutorService)
작업 생성
스레드 1
수락 작업 처리
각 스레드는 큐에서
작업을 가져와 실행시킴
스레드 수
제한
작업 큐
작업 생성
작업 생성
⑤ 응답
③ 요청
③ 요청
① 접속
…
…
스레드 2
요청 작업 처리
클라이언트1…n
(SocketChannel)
② SocketChannel 생성
④ SocketChannel 사용
accept()
스레드풀을 이용할 경우 클라이언트의 폭증은 작업 큐의 작업량만 증가시킬 뿐, 전체 스레드의 수에
는 변함이 없기 때문에 서버 성능은 완만히 저하된다. 다만 대기하는 작업량이 증가하기 때문에 개별 
클라이언트에서 응답을 늦게 받을 수 있다.
다음 예제는 100개의 클라이언트가 동시에 서버로 데이터를 보내고 받는 예제이다. 서버는 모든 클
라이언트의 요청을 처리하기 위해 단 10개의 스레드만 사용한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">sec06.exam03_threadpool</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.InetSocketAddress</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.ByteBuffer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.ServerSocketChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.SocketChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.Charset</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.ExecutorService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.Executors</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServerExample</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">try</span> <span class="o">{</span>
   <span class="c1">//스레드풀 생성</span>
   <span class="nc">ExecutorService</span> <span class="n">executorService</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
   <span class="c1">//ServerSocketChannel 열기</span>
   <span class="nc">ServerSocketChannel</span> <span class="n">serverSocketChannel</span> <span class="o">=</span> <span class="nc">ServerSocketChannel</span><span class="o">.</span><span class="na">open</span><span class="o">();</span>
   <span class="c1">//ServerSocketChannel 포트 바인딩</span>
   <span class="n">serverSocketChannel</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="k">new</span> <span class="nc">InetSocketAddress</span><span class="o">(</span><span class="mi">50001</span><span class="o">));</span>
   
   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[서버 시작]"</span><span class="o">);</span>
   <span class="c1">//스레드풀 작업 처리</span>
   <span class="n">executorService</span><span class="o">.</span><span class="na">execute</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
     <span class="c1">//지속적인 클라이언트 연결 요청 수락</span>
     <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">SocketChannel</span> <span class="n">socketChannel</span> <span class="o">=</span> <span class="n">serverSocketChannel</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
      <span class="nc">InetSocketAddress</span> <span class="n">isa</span> <span class="o">=</span> 
        <span class="o">(</span><span class="nc">InetSocketAddress</span><span class="o">)</span> <span class="n">socketChannel</span><span class="o">.</span><span class="na">getRemoteAddress</span><span class="o">();</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isa</span><span class="o">.</span><span class="na">getHostName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" 연결 수락"</span><span class="o">);</span>
      <span class="c1">//스레드풀 작업 처리</span>
      <span class="n">executorService</span><span class="o">.</span><span class="na">execute</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   //작업 스레드 이름 얻기
  String threadName = Thread.currentThread().getName();
   
   try {
    Charset charset = Charset.forName("UTF-8");
    //클라이언트가 보մ 데이터 받기
    ByteBuffer byteBuffer = ByteBuffer.allocate(100);
    int byteNum = socketChannel.read(byteBuffer);
    if (byteNum = = -1) {
     throw new IOException();
    }
    byteBuffer.flip();
    String message = charset.decode(byteBuffer).toString();
    System.out.println("[" + threadName + "]" +
      isa.getHostName() + " 데이터 받기: " + message);
    //클라이언트로 데이터 보내기
    byteBuffer = charset.encode("Hello Client");
    socketChannel.write(byteBuffer);
    System.out.println("[" + threadName + "]" +
      isa.getHostName() + " 데이터 보냄");
   } catch (Exception e) {
   } finally {
    try {
     //연결 끊기
     System.out.println("[" + threadName + "]" +
       isa.getHostName() + " 연결 끊기");
     socketChannel.close();
    } catch (Exception e) {
    }
   }
  });
 }
} catch (Exception e) {
 e.printStackTrace();
} finally {
 try {
  //ServerSocketChannel 닫기


  serverSocketChannel.close();
  //스레드풀 종료
  executorService.shutdown();
 } catch (Exception e) {
 }
}    });   } catch (Exception e) {    e.printStackTrace();   }  } } 실행 결과 [서버 시작]
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">sec06.exam03_threadpool</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.InetSocketAddress</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.ByteBuffer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.SocketChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.Charset</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClientExample</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
   <span class="c1">//SocketChannel 변수 선언</span>
   <span class="nc">SocketChannel</span> <span class="n">socketChannel</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
 
   <span class="k">try</span> <span class="o">{</span>
    <span class="c1">//SocketChannel 열기</span>
    <span class="n">socketChannel</span> <span class="o">=</span> <span class="nc">SocketChannel</span><span class="o">.</span><span class="na">open</span><span class="o">();</span>
 
    <span class="c1">//로컬 PC의 50001에서 실행 중인 ServerSocketChannel로 연결 요청</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>System.out.println("[연결 요청]");
socketChannel.connect(new InetSocketAddress("localhost", 50001));
System.out.println("[연결 성공]");
 
ByteBuffer byteBuffer = null;
Charset charset = Charset.forName("UTF-8");
 
//서버로 데이터 보내기
byteBuffer = charset.encode("Hello Server " + i);
socketChannel.write(byteBuffer);
System.out.println(i + "번째 데이터 보냄");
 
//서버가 보մ 데이터 받기
byteBuffer = ByteBuffer.allocate(100);
int byteNum = socketChannel.read(byteBuffer);
if(byteNum = = -1) {
 throw new IOException(); 
}
byteBuffer.flip();
String message = charset.decode(byteBuffer).toString();
System.out.println(i + "번째 데이터 받기: " + message);    } catch (Exception e) {
e.printStackTrace();    } finally {
//SocketChannel 닫기
try {
 System.out.println("[연결 끊기]");
 socketChannel.close();
} catch (IOException e1) {
}    }    System.out.println();   }  } }
</code></pre></div></div>

<p>실행 결과
ClientExample.java
ServerExample.java
[연결 요청]
[연결 성공]
1번째 데이터 보냄
1번째 데이터 받기: Hello Client
[연결 끊기]
[연결 요청]
[연결 성공]
2번째 데이터 보냄
2번째 데이터 받기: Hello Client
[연결 끊기]
[연결 요청]
[연결 성공]
3번째 데이터 보냄
3번째 데이터 받기: Hello Client
[연결 끊기]
…
[서버 시작]
127.0.0.1 연결 수락
[pool-1-thread-2]127.0.0.1 데이터 받기: Hello Server 1
[pool-1-thread-2]127.0.0.1 데이터 보냄
[pool-1-thread-2]127.0.0.1 연결 끊기
127.0.0.1 연결 수락
[pool-1-thread-3]127.0.0.1 데이터 받기: Hello Server 2
[pool-1-thread-3]127.0.0.1 데이터 보냄
[pool-1-thread-3]127.0.0.1 연결 끊기
127.0.0.1 연결 수락
[pool-1-thread-4]127.0.0.1 데이터 받기: Hello Server 3
[pool-1-thread-4]127.0.0.1 데이터 보냄
[pool-1-thread-4]127.0.0.1 연결 끊기
…</p>

<p>서버 실행 결과를 보면 100개의 클라이언트가 보내는 데이터를 받고 다시 보내는 작업을 처리하기 
위해 단 10개의 스레드(pool-1-thread1 ~ pool-1-thread-10)만 사용하는 것을 볼 수 있다.</p>

<h2 id="07-tcp-비동기-네트워크-입출력">07. TCP 비동기 네트워크 입출력</h2>

<p>NIO는 TCP 채널 이외에 TCP 비동기 채널(AsynchronousServerSocketChannel과 
AsynchronousSocketChannel)도 제공한다. TCP 비동기 채널은 연결 요청(connect( ) ), 연
결 수락(accept( ) ), 읽기(read( ) ), 쓰기(write( ) )를 호출하면 스레드풀에게 작업 처리를 요청하
고 즉시 리턴된다.
실질적인 작업 처리는 스레드풀의 작업 스레드가 담당한다. 작업 스레드가 작업을 완료하게 되면 콜
백callback 메소드가 자동 호출되기 때문에 작업 완료 후 실행해야 할 코드가 있다면 콜백 메소드에서 
작성할 수 있다.</p>

<p>비동기 처리 방식
스레드풀
스레드 1
스레드 1
⑤ 작업 처리
스레드 2
각 스레드는 큐에서
작업을 가져와 실행시킴
스레드 n
⑤ 작업 처리
④ 작업 큐
① accept()
② 즉시 리턴
⑥ 콜백 메소드 호출
① read()/write()
② 즉시 리턴
⑥ 콜백 메소드 호출
③ 작업 처리 요청
③ 작업 처리 요청
스레드 2
최
대
개
수
제
한
…
비동기
채널1
비동기
채널2
애플리케이션에서 read( ) 메소드를 호출하면 즉시 리턴되지만, 내부에서는 스레드풀의 작업 스레
드가 읽기 작업을 수행한다. 작업이 완료되면 콜백 메소드인 completed( )가 자동 호출된다.
작업 스레드
③ 실행
콜백
② read() 호출
즉시 리턴
스레드풀(ExecutorService)
SFBE	
\</p>
<p>completed() 메소드
④ 실행
① 실행
비동기 채널 그룹
비동기 서버 소켓 채널과 비동기 소켓 채널을 살펴보기 전에 우선 비동기 채널 그룹에 대해서 이해
해 보자. 비동기 채널 그룹(AsynchronousChannelGroup)은 같은 스레드풀을 공유하는 비동기 
채널들의 묶음이라고 볼 수 있다.</p>

<p>각 스레드는 큐에서
작업을 가져와 실행시킴
AsynchronousServerSocket
AsynchronousSocket
AsynchronousSocket
작업 큐
연결 수락 요청
입출력 요청
비동기 채널 그룹
(AsynchronousChannelGroup)
스레드풀(ExecutorService)
…
스레드 1
연결 수락 처리
스레드 1
연결 수락 처리
스레드 n
…
비동기 채널을 생성할 때 채널 그룹을 지정하지 않으면 기본 비동기 채널 그룹이 생성된다. 기본 비
동기 채널 그룹은 내부적으로 다음과 같이 스레드풀을 생성한다
new ThreadPoolExecutor(
 0, Integer.MAX_VALUE,
 Long.MAX_VALUE, TimeUnit.MILLISECONDS,
 new SynchronousQueue<Runnable>(),
 threadFactory
);
이론적으로 Integer.MAX_VALUE개만큼 스레드가 증가할 수 있도록 되어 있다. 하지만 스레드풀
은 대부분 최대 스레드 수를 지정해서 사용하므로 다음과 같이 사용자 비동기 채널 그룹을 직접 생
성하는 것이 일반적이다.
AsynchronousChannelGroup channelGroup = AsynchronousChannelGroup.withFixedThreadPool(
 maxThreadNum, 
 Executors.defaultThreadFactory()
);</Runnable></p>

<p>다음은 CPU 코어의 수만큼 스레드를 관리하는 스레드풀을 생성하고 이것을 이용하는 비동기 채널 그
룹을 생성한다.
AsynchronousChannelGroup channelGroup = AsynchronousChannelGroup.withFixedThreadPool(
 Runtime.getRuntime().availableProcessors(),
 Executors.defaultThreadFactory()
);
이렇게 생성된 비동기 채널 그룹은 비동기 채널을 생성할 때 매개값으로 사용된다. 비동기 채널 그룹
을 더 이상 사용하지 않고 종료할 경우에는 shutdown( )과 shutdownNow( ) 메소드를 호출할 
수 있다.
channelGroup.shutdown();
channelGroup.shutdownNow();
shutdown( )은 비동기 채널 그룹을 종료하겠다는 의사만 전달할 뿐 즉시 비동기 채널 그룹을 종료
하지 않는다. 비동기 채널 그룹에 포함된 모든 비동기 채널이 닫히면 비로소 비동기 채널 그룹을 종
료시킨다. 
shutdownNow( )는 강제적으로 비동기 채널 그룹에 포함된 모든 비동기 채널을 닫아버리고 비동
기 채널 그룹을 종료한다. 
비동기 서버 소켓 채널
AsynchronousServerSocketChannel은 두 가지 정적 메소드인 open( )을 호출해서 얻을 수 
있다. 다음과 같이 매개값 없는 open( ) 메소드를 호출하면 기본 비동기 채널 그룹에 포함되는 
AsynchronousServerSocketChannel을 얻을 수 있다.
AsynchronousServerSocketChannel assc = AsynchronousServerSocketChannel.open();
별도로 비동기 채널 그룹을 생성하고 여기에 포함되는 AsynchronousServerSocketChannel을 
얻고 싶다면 다음과 같이 비동기 채널 그룹을 매개값으로 갖는 open( ) 메소드를 호출하면 된다.</p>

<p>AsynchronousChannelGroup channelGroup = AsynchronousChannelGroup.withFixedThreadPool(
 ୭대스레드수, Executors.defaultThreadFactory()
);
AsynchronousServerSocketChannel assc = AsynchronousServerSocketChannel.open
   (channelGroup);
AsynchronousServerSocketChannel을 생성하고 나서는 포트 바인딩을 위해 다음과 같이 
bind( ) 메소드를 호출한다.
assc.bind(new InetSocketAddress(50001));
바인딩 작업이 끝나면 클라이언트의 연결 요청을 수락할 수 있는 accept( ) 메소드를 다음과 같이
호출할 수 있다. 이 메소드는 호출 즉시 리턴되지만 스레드풀에서 연결 수락 작업을 진행한다.
assc.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, Void&gt;() {
  @Override
  public void completed(AsynchronousSocketChannel asc, Void attachment) {
    //연결 수락 후 실행할 코드
    //…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//다음 연결 수락을 위해 accept() 재호출    assc.accept(null, this);    }   @Override   public void failed(Throwable exc, Void attachment) {
//연결 수락 실패 시 실행할 코드
//…   } }); 첫 번째 매개값은 콜백 메소드의 매개값으로 제공할 첨부 객체인데, 연결 수락 작업에는 별도의 첨 부 객체가 필요하지 않기 때문에 null을 지정한다. 두 번째 매개값은 콜백 객체로, CompletionHa ndler&lt;AsynchronousSocketChannel, A&gt; 구현 객체이다. A는 첨부 객체 타입인데, 첫 번째 매 개값이 null이므로 Void로 지정한다. 
</code></pre></div></div>

<p>completed( )는 연결 수락이 되었을 때 스레드풀의 스레드에서 호출되는 콜백 메소드이다. 첫 번
째 매개값은 클라이언트와 통신할 수 있는 AsynchronousSocketChannel이고, 두 번째 매개값
은 첨부 객체인데 없기 때문에 null이 대입된다. 
failed( )는 연결 수락 시에 예외가 발생되면 스레드풀의 스레드에서 호출되는 콜백 메소드이다. 첫 
번째 매개값은 예외 객체이고 두 번째 매개값은 첨부 객체인데 없기 때문에 null이 대입된다. 
주목할 점은 클라이언트의 연결 수락을 계속하기 위해 accept( ) 메소드를 반복 호출하는 제어문이 
없고, 대신 completed( ) 메소드 끝에 다음 연결 수락을 위해 accept( )를 다시 호출한다.
클라이언트의 연결 수락 작업을 멈추고 싶다면 다음과 같이 AsynchronousServerSocketChannel
의 close( ) 메소드를 호출해서 포트를 언바인딩할 수 있다.
assc.close();
다음 예제는 계속적으로 클라이언트의 연결 수락 작업을 수행하는 가장 기본적인 TCP 비동기 서버 
코드를 보여준다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">sec07.exam01_asynchronous_tcpchannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.InetSocketAddress</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.AsynchronousChannelGroup</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.AsynchronousServerSocketChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.AsynchronousSocketChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.CompletionHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.Executors</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServerExample</span> <span class="o">{</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="nc">AsynchronousChannelGroup</span> <span class="n">channelGroup</span><span class="o">;</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="nc">AsynchronousServerSocketChannel</span> <span class="n">assc</span><span class="o">;</span> 
 
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[서버 시작]"</span><span class="o">);</span> 
 
</code></pre></div></div>

<p>try {
   //비동기 채널 그룹 생성
   channelGroup = AsynchronousChannelGroup.withFixedThreadPool(
     10, Executors.defaultThreadFactory());</p>

<p>//비동기 서버 소켓 채널 생성
   assc = AsynchronousServerSocketChannel.open(channelGroup);</p>

<p>//포트 바인딩
   assc.bind(new InetSocketAddress(50001));</p>

<p>//클라이언트 연결 수락하기
   assc.accept(
    null, 
    new CompletionHandler&lt;AsynchronousSocketChannel, Void&gt;() {
     @Override
     public void completed(AsynchronousSocketChannel asc,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     Void attachment) {
  try {
   InetSocketAddress isa = (InetSocketAddress) 
 
       asc.getRemoteAddress();
   System.out.println(isa.getHostName() + " 연결 수락");
   try { asc.close(); } catch (Exception e) {}
   System.out.println(isa.getHostName() + " 연결 종료");
  } catch (IOException e) {}
  
  //다음 클라이언트 연결 수락하기
  assc.accept(null, this);
 }   
 @Override
 public void failed(Throwable e, Void attachment) {
 }
}    );
</code></pre></div></div>

<p>//키보드 입력이 있을 때까지 대기
   try { System.in.read(); } catch (Exception e) {}
  } catch (Exception e) {
   e.printStackTrace();
  } finally {</p>

<p>try {
    assc.close();
    channelGroup.shutdownNow();
   } catch (Exception e) {}
  }</p>

<p>System.out.println(“[서버 종료]”);
 }
}
실행 결과
[서버 시작]
비동기 소켓 채널
AsynchronousSocketChannel은 서버와 클라이언트에 각각 존재하는데, 클라이언
트가 AsynchronousSocketChannel을 생성해서 서버로 연결 요청을 하면 서버의 
AsynchronousServerSocketChannel은 연결 수락 후 AsynchronousSocketChannel을 생
성해서 서로 통신할 수 있도록 만들어준다. 
AsynchronousServerSocketChannel이 생성하는 AsynchronousSocketChannel은 자동적
으로 AsynchronousServerSocketChannel과 같은 비동기 채널 그룹에 속하게 된다.
클라이언트에서 AsynchronousSocketChannel을 생성하려면 두 가지 open( ) 메소드를 사
용할 수 있다. 다음과 같이 매개값없는 open( ) 메소드를 호출하면 기본 비동기 채널에 포함되는 
AsynchronousSocketChannel을 얻을 수 있다.
AsynchronousSocketChannel asc = AsynchronousSocketChannel.open();
별도로 비동기 채널 그룹을 생성하고 여기에 포함되는 AsynchronousSocketChannel을 얻고 싶
다면 다음과 같이 비동기 채널 그룹을 매개값으로 갖는 open( ) 메소드를 호출하면 된다</p>

<p>AsynchronousChannelGroup channelGroup = AsynchronousChannelGroup.withFixedThreadPool(
 ୭대스레드수, Executors.defaultThreadFactory()
);
AsynchronousSocketChannel asc = AsynchronousSocketChannel.open(channelGroup);
AsynchronousSocketChannel은 서버 연결 요청 작업을 스레드풀을 이용해서 비동기로 처리한
다. 다음은 connect( ) 메소드를 호출하는 코드이다.
asc.connect(
 new InetSocketAddress(“localhost”, 5001), 
 null,
 new CompletionHandler&lt;Void, Void&gt;() {
  @Override
  public void completed(Void result, Void attachment) {
    //연결 성공 후 실행할 코드
    //…
  }
  @Override
  public void failed(Throwable e, Void attachment) {
    //연결 실패 후 실행할 코드
    //…
  }
});
첫 번째 매개값은 서버 IP와 연결 포트 정보를 가진 InetSocketAddress 객체이다. 두 번째 매개값
은 콜백 객체에서 사용할 첨부 객체인데, 연결 요청 작업에는 별도의 첨부 객체가 필요하지 않기 때
문에 null을 지정한다. 
세 번째 매개값은 CompletionHandler&lt;Void, A&gt;를 구현한 콜백 객체이다. A는 첨부 타입을 말
하는데, 두 번째 매개값을 null로 지정했기 때문에 Void로 지정한다. 
completed( )는 연결이 성공했을 때 스레드풀의 스레드에서 호출되는 콜백 메소드이다. 첫 번째 
매개값은 무조건 null이 대입되고, 두 번째 매개값은 첨부 객체인데, 없기 때문에 null이 대입된다. 
failed( )는 연결 요청 시 예외가 발생하면 스레드풀의 스레드에서 호출되는 콜백 메소드이다. 첫 번
째 매개값은 예외 객체이고, 두 번째 매개값은 첨부 객체인데 없기 때문에 null이 대입된다.</p>

<p>AsynchronousSocketChannel을 더 이상 사용하지 않을 경우에는 close( ) 메소드를 호출해서 
연결을 끊어준다.
asynchronousSocketChannel.close();
다음 예제는 서버로 연결 요청을 하는 가장 기본적인 TCP 비동기 클라이언트 코드를 보여준다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">sec07.exam01_asynchronous_tcpchannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.InetSocketAddress</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.AsynchronousSocketChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.CompletionHandler</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClientExample</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[클라이언트 시작]"</span><span class="o">);</span>
  
  <span class="k">try</span> <span class="o">{</span>
   <span class="c1">//비동기 소켓 채널 생성</span>
   <span class="nc">AsynchronousSocketChannel</span> <span class="n">asc</span> <span class="o">=</span> <span class="nc">AsynchronousSocketChannel</span><span class="o">.</span><span class="na">open</span><span class="o">();</span>
   
   <span class="c1">//서버로 연결 요청하기</span>
   <span class="n">asc</span><span class="o">.</span><span class="na">connect</span><span class="o">(</span>
     <span class="k">new</span> <span class="nf">InetSocketAddress</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">,</span> <span class="mi">50001</span><span class="o">),</span> 
     <span class="kc">null</span><span class="o">,</span> 
     <span class="k">new</span> <span class="nc">CompletionHandler</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">,</span> <span class="nc">Void</span><span class="o">&gt;()</span> <span class="o">{</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">completed</span><span class="o">(</span><span class="nc">Void</span> <span class="n">result</span><span class="o">,</span> <span class="nc">Void</span> <span class="n">attachment</span><span class="o">)</span> <span class="o">{</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"연결 성공"</span><span class="o">);</span>
       <span class="k">try</span> <span class="o">{</span> <span class="n">asc</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"연결 종료"</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">failed</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">exc</span><span class="o">,</span> <span class="nc">Void</span> <span class="n">attachment</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">exc</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
       <span class="k">try</span> <span class="o">{</span> <span class="n">asc</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  }
}    );
</code></pre></div></div>

<p>//키보드 입력이 있을 때까지 대기
   try { System.in.read(); } catch (Exception e) {}
  } catch (Exception e) {
   e.printStackTrace();
  }</p>

<p>System.out.println(“[클라이언트 종료]”);
 }
}
실행 결과
ClientExample.java
ServerExample.java
[클라이언트 시작]
연결 성공
연결 종료
[Enter]
[클라이언트 종료]
[서버 시작]
127.0.0.1 연결 수락
127.0.0.1 연결 종료
[Enter]
[서버 종료]</p>

<p>네트워크 입출력
클라이언트와 서버가 연결되면 양쪽 AsynchronousSocketChannel의 read( )와 write( ) 메소
드로 네트워크 입출력을 할 수 있다. 이 메소드들은 호출하는 즉시 리턴되고, 실질적인 입출력 작업
은 스레드풀의 스레드가 담당한다. 다음은 read( )와 write( )를 호출하는 코드이다.
read(ByteBuffer dst, A attachment, CompletionHandler&lt;Integer, A&gt; handler);
write(ByteBuffer src, A attachment, CompletionHandler&lt;Integer, A&gt; handler);
첫 번째 매개값은 읽고 쓰기 위한 ByteBuffer 객체이고, 두 번째 매개값은 콜백 객체에서 사용할 
첨부 객체이다. 세 번째 매개값은 CompletionHandler&lt;Integer, A&gt;를 구현한 콜백 객체인데, 다
음과 같이 생성할 수 있다.</p>

<p>new CompletionHandler&lt;Integer, A&gt;() {
  @Override
  public void completed(Integer result, A attachment) {
    //입출력 작업이 완료되면 실행
    //…
  }
  @Override
  public void failed(Throwable exc, A attachment) {
    //입출력 작업 시 예외가 발생하면 실행
    //…
  }
}
completed( )는 입출력이 완료되었을 때 스레드풀의 스레드에서 호출되는 콜백 메소드이다. 첫 번
째 매개 값은 입출력된 바이트 수이고, 두 번째 매개값은 첨부 객체인데, read( )와 write( )를 호출
할 때 준 두 번째 매개값에 해당한다. 
failed( )는 입출력 작업 시 예외가 발생하면 스레드풀의 스레드에서 호출되는 콜백 메소드이다. 첫 
번째 매개값은 예외 객체이고, 두 번째 매개값은 첨부 객체인데, read( )와 write( )를 호출할 때 준 
두 번째 매개값에 해당한다. 
read( ) 메소드를 호출할 경우에는 상대방이 보내는 데이터를 계속 입력받기 위해서 콜백 객체의 
completed( ) 메소드 끝에 다음과 같이 read( ) 메소드를 다시 호출할 수도 있다.
@Override
public void completed(Integer result, A attachment) {
  //받은 데이터를 처리하는 코드
   //…
  asc.read(byteBuffer, attachment, this);<br />
}
다음 예제는 100개의 클라이언트가 동시에 서버로 데이터를 보내고 받는 예제이다. 서버는 모든 클
라이언트의 요청을 처리하기 위해 10개의 스레드로 비동기 처리한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">sec07.exam02_data_read_write</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.InetSocketAddress</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.ByteBuffer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.AsynchronousChannelGroup</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.AsynchronousServerSocketChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.AsynchronousSocketChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.CompletionHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.Charset</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.Executors</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServerExample</span> <span class="o">{</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="nc">AsynchronousChannelGroup</span> <span class="n">channelGroup</span><span class="o">;</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="nc">AsynchronousServerSocketChannel</span> <span class="n">assc</span><span class="o">;</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[서버 시작]"</span><span class="o">);</span>
  
  <span class="k">try</span> <span class="o">{</span>
   <span class="c1">//비동기 채널 그룹 생성</span>
   <span class="n">channelGroup</span> <span class="o">=</span> <span class="nc">AsynchronousChannelGroup</span><span class="o">.</span><span class="na">withFixedThreadPool</span><span class="o">(</span>
     <span class="mi">10</span><span class="o">,</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">defaultThreadFactory</span><span class="o">());</span>
  
   <span class="c1">//비동기 서버 소켓 채널 생성</span>
   <span class="n">assc</span> <span class="o">=</span> <span class="nc">AsynchronousServerSocketChannel</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="n">channelGroup</span><span class="o">);</span>
   
   <span class="c1">//포트 바인딩</span>
   <span class="n">assc</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="k">new</span> <span class="nc">InetSocketAddress</span><span class="o">(</span><span class="mi">50001</span><span class="o">));</span>
   
   <span class="c1">//클라이언트 연결 수락하기</span>
   <span class="n">assc</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span>
    <span class="kc">null</span><span class="o">,</span> 
    <span class="k">new</span> <span class="nc">CompletionHandler</span><span class="o">&lt;</span><span class="nc">AsynchronousSocketChannel</span><span class="o">,</span> <span class="nc">Void</span><span class="o">&gt;()</span> <span class="o">{</span>
     <span class="nd">@Override</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">completed</span><span class="o">(</span><span class="nc">AsynchronousSocketChannel</span> <span class="n">asc</span><span class="o">,</span> 
 
         <span class="nc">Void</span> <span class="n">attachment</span><span class="o">)</span> <span class="o">{</span> 
 
 
 
 
 
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  //클라이언트가 보մ 데이터 받기
  receive(asc);
  
  //다음 클라이언트 연결 수락하기
  assc.accept(null, this);
 }
 
 @Override
 public void failed(Throwable exc, Void attachment) {
 }
}    );
</code></pre></div></div>

<p>//키보드 입력이 있을 때까지 대기
   try { System.in.read(); } catch (Exception e) {}
  } catch (Exception e) {
   e.printStackTrace();
  } finally {
   try {
    assc.close();
    channelGroup.shutdownNow();
   } catch (Exception e) {}
  }
  System.out.println(“[서버 종료]”);
 }</p>

<p>//클라이언트가 보մ 데이터 받기
 public static void receive(AsynchronousSocketChannel asc) {
  ByteBuffer byteBuffer = ByteBuffer.allocate(100);
  asc.read(byteBuffer, byteBuffer, new CompletionHandler&lt;Integer,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ByteBuffer&gt;() {    @Override    public void completed(Integer result, ByteBuffer attachment) {
try {
 attachment.flip();
 Charset charset = Charset.forName("utf-8");
 String receiveData = charset.decode(attachment).toString();
 
 String threadName = Thread.currentThread().getName();


 System.out.println("[" + threadName + "] " + "데이터 받음: " + 
 
     receiveData); 
 
 
 //클라이언트로 데이터 보내기
 send(asc, receiveData);
} catch(Exception e) {}    }
</code></pre></div></div>

<p>@Override
   public void failed(Throwable exc, ByteBuffer attachment) {
    exc.printStackTrace();
    try { asc.close(); } catch (IOException e) {}
   }
  });
 }</p>

<p>//클라이언트로 데이터 보내기
 public static void send(AsynchronousSocketChannel asc,</p>

<p>String receiveData) {
  String sendData = “Hello Client “ + receiveData.substring(13);
  Charset charset = Charset.forName(“utf-8”);
  ByteBuffer byteBuffer = charset.encode(sendData);
  asc.write(byteBuffer, sendData, new CompletionHandler&lt;Integer,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>String&gt;() {    @Override    public void completed(Integer result, String attachment) {
String threadName = Thread.currentThread().getName();
System.out.println("[" + threadName + "] " + "데이터 보냄: " + 
 
    attachment);
try { asc.close(); } catch (IOException e) {}    }
</code></pre></div></div>

<p>@Override
   public void failed(Throwable exc, String attachment) {
    exc.printStackTrace();
    try { asc.close(); } catch (IOException e) {}
   }
  });
 }
}</p>

<p>실행 결과
[서버 시작]</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">sec07.exam02_data_read_write</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.InetSocketAddress</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.ByteBuffer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.AsynchronousSocketChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.CompletionHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.Charset</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClientExample</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[클라이언트 시작]"</span><span class="o">);</span>
  <span class="k">try</span> <span class="o">{</span>
   <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="c1">//비동기 소켓 채널 생성</span>
    <span class="nc">AsynchronousSocketChannel</span> <span class="n">asc</span> <span class="o">=</span> <span class="nc">AsynchronousSocketChannel</span><span class="o">.</span><span class="na">open</span><span class="o">();</span>
    <span class="c1">//서버로 연결 요청하기</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
    <span class="n">asc</span><span class="o">.</span><span class="na">connect</span><span class="o">(</span><span class="k">new</span> <span class="nc">InetSocketAddress</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">,</span> <span class="mi">50001</span><span class="o">),</span> <span class="kc">null</span><span class="o">,</span> 
     <span class="k">new</span> <span class="nc">CompletionHandler</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">,</span> <span class="nc">Void</span><span class="o">&gt;()</span> <span class="o">{</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">completed</span><span class="o">(</span><span class="nc">Void</span> <span class="n">result</span><span class="o">,</span> <span class="nc">Void</span> <span class="n">attachment</span><span class="o">)</span> <span class="o">{</span>
       <span class="c1">//서버로 데이터 보내기</span>
       <span class="n">receive</span><span class="o">(</span><span class="n">asc</span><span class="o">,</span> <span class="n">count</span><span class="o">);</span>
      <span class="o">}</span>
 
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">failed</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">exc</span><span class="o">,</span> <span class="nc">Void</span> <span class="n">attachment</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">exc</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
       <span class="k">try</span> <span class="o">{</span> <span class="n">asc</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
      <span class="o">}</span>
     <span class="o">}</span>
    <span class="o">);</span>
</code></pre></div></div>

<p>}
   //키보드 입력이 있을 때까지 대기
   try { System.in.read(); } catch (Exception e) {}
  } catch (Exception e) {
   e.printStackTrace();
  }
  System.out.println(“[클라이언트 종료]”);
 }</p>

<p>//서버로 데이터 보내기
 public static void receive(AsynchronousSocketChannel asc, int count) {
  Charset charset = Charset.forName(“utf-8”);
  String sendData = “Hello Server “ + count;
  ByteBuffer byteBuffer = charset.encode(sendData);
  asc.write(byteBuffer, null, new CompletionHandler&lt;Integer, Void&gt;() {
   @Override
   public void completed(Integer result, Void attachment) {
    System.out.println(“데이터 보냄: “ + sendData);
    //서버가 보մ 데이터 받기
    send(asc);
   }
   @Override
   public void failed(Throwable exc, Void attachment) {
    exc.printStackTrace();
    try {
     asc.close();
    } catch (Exception e) {
    }
   }
  });
 }</p>

<p>//서버가 보մ 데이터 받기
 public static void send(AsynchronousSocketChannel asc) {
  ByteBuffer byteBuffer = ByteBuffer.allocate(100);
  asc.read(byteBuffer, byteBuffer, new CompletionHandler&lt;Integer,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ByteBuffer&gt;() {
</code></pre></div></div>

<p>@Override
   public void completed(Integer result, ByteBuffer attachment) {
    try {
     attachment.flip();
     Charset charset = Charset.forName(“utf-8”);
     String receiveData = charset.decode(attachment).toString();
     System.out.println(“데이터 받음: “ + receiveData);
     asc.close();
    } catch (Exception e) {
    }
   }
   @Override
   public void failed(Throwable exc, ByteBuffer attachment) {
    exc.printStackTrace();
    try { asc.close(); } catch (Exception e) {}
   }
  });
 }
}
실행 결과
ClientExample.java
ServerExample.java
[클라이언트 시작]
…
데이터 보냄: Hello Server 92
데이터 받음: Hello Client 70
데이터 보냄: Hello Server 93
데이터 보냄: Hello Server 94
데이터 받음: Hello Client 71
데이터 보냄: Hello Server 95
…
[Enter]
[클라이언트 종료]
[서버 시작]
…
[pool-1-thread-4] 데이터 받음: Hello Server 94
[pool-1-thread-6] 데이터 보냄: Hello Client 94
[pool-1-thread-4] 데이터 받음: Hello Server 95
[pool-1-thread-6] 데이터 보냄: Hello Client 95
[pool-1-thread-6] 데이터 받음: Hello Server 96
[pool-1-thread-3] 데이터 보냄: Hello Client 96
…
[Enter]
[서버 종료]</p>

<h2 id="08-udp-네트워크-입출력">08. UDP 네트워크 입출력</h2>

<p>NIO에서 UDP 채널은 데이터그램 채널DatagramChannel이다. 서버와 클라이언트는 데이터그램 채널을 
이용해서 버퍼의 데이터를 입출력한다.
UDP 클라이언트
UDP 서버
③ 통신(send, receive)
버
퍼
Datagram
Channel
버
퍼
Datagram
Channel
데이터그램 채널
DatagramChannel을 생성하려면 open( ) 메소드를 호출해야 한다. 매개값으로 ProtocolFamily 
인터페이스 구현 객체가 필요한데, 이 객체는 StandardProtocolFamily 열거 상수를 사용한다. 
다음은 IPv4를 사용하는 DatagramChannel을 생성하는 코드이다.
DatagramChannel datagramChannel = DatagramChannel.open(StandardProtocolFamily.INET);
UDP 서버가 되려면 DatagramChannel이 특정 포트port와 바인딩되어야 한다. 이 포트는 클라이
언트가 데이터를 보낼 때 사용된다. 다음은 50001번 포트와 바인딩하기 위해 bind( ) 메소드를 호
출하는 방법을 보여준다. 
datagramChannel.bind(new InetSocketAddress(50001));
네트워크 입출력
상대방이 메시지를 보내면 DatagramChannel의 receive( ) 메소드로 다음과 같이 읽을 수 있다.</p>

<p>InetSocketAddress isa = (InetSocketAddress) datagramChannel.receive(byteBuffer);
receive( ) 메소드의 매개값은 받은 데이터를 저장할 ByteBuffer이다. 데이터를 받기 전까지 
receive( ) 메소드는 블로킹되고, 데이터를 받으면 리턴된다. 리턴 타입은 SocketAddress인데, 
실제로는 InetSocketAddress 객체가 리턴된다. InetSocketAddress를 통해 상대방의 IP와 포
트 정보를 다음과 같이 알 수 있다.
String clientIp = isa.getHostName();
int clientPort = isa.getPort(); 
상대방에게 데이터를 보내기 위해서는 send( ) 메소드를 이용한다. 다음은 로컬 PC의 50001번에
서 실행하고 있는 UDP 서버로 데이터를 보낸다.
int byteCount = datagramChannel.send(byteBuffer, new InetSocketAddress
(“localhost”, 50001));
send( )의 첫 번째 매개값은 보낼 데이터를 가지고 있는 ByteBuffer이고, 두 번째 매개값은 수신
자 IP와 포트 정보를 가지고 있는 SocketAddress이다. SocketAddress는 추상 클래스이므로 하
위 클래스인 InetSocketAddress 객체를 생성하고 대입하면 된다. send( ) 메소드의 리턴값은 실
제로 보낸 바이트 수이다.
더 이상 네트워크 입출력이 필요없다면 DatagramChannel을 닫기 위해 close( ) 메소드를 호출
한다.
datagramChannel.close();
다음 예제는 UDP 서버가 데이터를 받고 다시 UDP 클라이언트로 보내는 방법을 보여준다. UDP 
클라이언트는 100번 데이터를 보내고, 100번 데이터를 받는다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">sec08</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.InetSocketAddress</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.StandardProtocolFamily</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.ByteBuffer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.DatagramChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.Charset</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServerExample</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[서버 시작]"</span><span class="o">);</span>
  
  <span class="nc">DatagramChannel</span> <span class="n">datagramChannel</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  
  <span class="k">try</span> <span class="o">{</span>
   <span class="c1">//DatagramChannel 생성</span>
   <span class="n">datagramChannel</span> <span class="o">=</span> <span class="nc">DatagramChannel</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="nc">StandardProtocolFamily</span><span class="o">.</span><span class="na">INET</span><span class="o">);</span>
   
   <span class="c1">//포트 바인딩</span>
   <span class="n">datagramChannel</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="k">new</span> <span class="nc">InetSocketAddress</span><span class="o">(</span><span class="mi">50001</span><span class="o">));</span>
   
   <span class="nc">Charset</span> <span class="n">charset</span> <span class="o">=</span> <span class="nc">Charset</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">);</span>
   <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
     <span class="c1">//클라이언트가 보մ 데이터 받기</span>
     <span class="nc">ByteBuffer</span> <span class="n">byteBuffer</span> <span class="o">=</span> <span class="nc">ByteBuffer</span><span class="o">.</span><span class="na">allocateDirect</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
     
     <span class="nc">InetSocketAddress</span> <span class="n">isa</span> <span class="o">=</span> 
         <span class="o">(</span><span class="nc">InetSocketAddress</span><span class="o">)</span> <span class="n">datagramChannel</span><span class="o">.</span><span class="na">receive</span><span class="o">(</span><span class="n">byteBuffer</span><span class="o">);</span>
     <span class="nc">String</span> <span class="n">clientIp</span> <span class="o">=</span> <span class="n">isa</span><span class="o">.</span><span class="na">getHostName</span><span class="o">();</span>
     <span class="kt">int</span> <span class="n">clientPort</span> <span class="o">=</span> <span class="n">isa</span><span class="o">.</span><span class="na">getPort</span><span class="o">();</span>
     
     <span class="n">byteBuffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>
     <span class="nc">String</span> <span class="n">receiveData</span> <span class="o">=</span> <span class="n">charset</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">byteBuffer</span><span class="o">).</span><span class="na">toString</span><span class="o">();</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"["</span> <span class="o">+</span> <span class="n">clientIp</span>  <span class="o">+</span> <span class="s">"] 데이터 받음: "</span> <span class="o">+</span> 
 
         <span class="n">receiveData</span><span class="o">);</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> //클라이언트로 데이터 보내기
 String sendData = "Hello Client " + receiveData.substring(13);
 byteBuffer = charset.encode(sendData);
 
 int byteCount = datagramChannel.send(
  byteBuffer,  
  new InetSocketAddress(clientIp, clientPort)
 );
 
 System.out.println("[" + clientIp  + "] 데이터 보냄: " + sendData);
} catch(IOException e) {
 e.printStackTrace();
 break;
}    }   } catch(Exception e) {    e.printStackTrace();   } finally {    //DatagramChannel 닫기    try { datagramChannel.close(); } catch(Exception e) {}   }
</code></pre></div></div>

<p>System.out.println(“[서버 종료]”);
 }
}
실행 결과
[서버 시작]</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">sec08</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.InetSocketAddress</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.StandardProtocolFamily</span><span class="o">;</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.nio.ByteBuffer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.channels.DatagramChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.Charset</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClientExample</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[클라이언트 시작]"</span><span class="o">);</span>
  
  <span class="nc">DatagramChannel</span> <span class="n">datagramChannel</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  
  <span class="k">try</span> <span class="o">{</span>
   <span class="c1">//DatagramChannel 생성</span>
   <span class="n">datagramChannel</span> <span class="o">=</span> <span class="nc">DatagramChannel</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="nc">StandardProtocolFamily</span><span class="o">.</span><span class="na">INET</span><span class="o">);</span>
   
   <span class="nc">Charset</span> <span class="n">charset</span> <span class="o">=</span> <span class="nc">Charset</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">);</span>
   <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
     <span class="c1">//서버로 데이터 보내기</span>
     <span class="nc">String</span> <span class="n">sendData</span> <span class="o">=</span> <span class="s">"Hello Server "</span> <span class="o">+</span> <span class="n">i</span><span class="o">;</span>
     <span class="nc">ByteBuffer</span> <span class="n">byteBuffer</span> <span class="o">=</span> <span class="n">charset</span><span class="o">.</span><span class="na">encode</span><span class="o">(</span><span class="n">sendData</span><span class="o">);</span>
     <span class="kt">int</span> <span class="n">byteCount</span> <span class="o">=</span> <span class="n">datagramChannel</span><span class="o">.</span><span class="na">send</span><span class="o">(</span>
      <span class="n">byteBuffer</span><span class="o">,</span>  
      <span class="k">new</span> <span class="nf">InetSocketAddress</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">,</span> <span class="mi">50001</span><span class="o">)</span>
     <span class="o">);</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"데이터 보냄: "</span> <span class="o">+</span> <span class="n">sendData</span><span class="o">);</span>
     
     <span class="c1">//서버가 보մ 데이터 받기</span>
     <span class="n">byteBuffer</span> <span class="o">=</span> <span class="nc">ByteBuffer</span><span class="o">.</span><span class="na">allocateDirect</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
    <span class="nc">InetSocketAddress</span> <span class="n">isa</span> <span class="o">=</span> 
 
        <span class="o">(</span><span class="nc">InetSocketAddress</span><span class="o">)</span> <span class="n">datagramChannel</span><span class="o">.</span><span class="na">receive</span><span class="o">(</span><span class="n">byteBuffer</span><span class="o">);</span>
     <span class="n">byteBuffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span> 
 
 
 
     <span class="nc">String</span> <span class="n">receiveData</span> <span class="o">=</span> <span class="n">charset</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">byteBuffer</span><span class="o">).</span><span class="na">toString</span><span class="o">();</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"데이터 받음: "</span> <span class="o">+</span> <span class="n">receiveData</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
     <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
     <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
   <span class="o">}</span>
  <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>


   <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
  <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
   <span class="c1">//DatagramChannel 닫기</span>
   <span class="k">try</span> <span class="o">{</span> <span class="n">datagramChannel</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
  <span class="o">}</span>
  
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[클라이언트 종료]"</span><span class="o">);</span>
 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>실행 결과</strong>
```text
ClientExample.java
ServerExample.java
[클라이언트 시작]
데이터 보냄: Hello Server 1
데이터 받음: Hello Client 1
…
데이터 보냄: Hello Server 100
데이터 받음: Hello Client 100
[클라이언트 종료]
[서버 시작]
[127.0.0.1] 데이터 받음: Hello Server 1
[127.0.0.1] 데이터 보냄: Hello Client 1
…
[127.0.0.1] 데이터 받음: Hello Server 100
[127.0.0.1] 데이터 보냄: Hello Client 100</p>

<h2 id="09-nio-과제">09. NIO 과제</h2>

<p>지금까지 학습한 내용을 기반으로 NIO 비동기 채널을 이용해서 다음과 같이 동작하는 채팅 서버와 
채팅 클라이언트 과제를 수행해 보자.
과제 1
UI 라이브러리는 JavaFX 또는 Swing 중 하나를 선택해서 사용하고, 서버와 클라이언트 UI를 다음
과 같이 만든다.</p>

<p>ClientExample.java
ServerExample.java</p>
<ul>
  <li>중앙: TextArea(JTextArea)</li>
  <li>[start] 버튼: Button(JButton)</li>
  <li>입력: TextField(JTextField)</li>
  <li>[send] 버튼: Button(JButton), 비활성화</li>
  <li>중앙: TextArea(JTextArea)</li>
  <li>[start] 버튼: Button(JButton)
과제 2
서버에서 [start] 버튼을 클릭하면 [서버 시작]이라고 출력되
고, [stop] 버튼으로 변경되도록 한다. 서버는 50001번 포트
에 바인딩되도록 한다.
과제 3
클라이언트에서 [start] 버튼을 클릭하면 서버에 연결 요청을 한다. 연결이 성공되면 연결 완료 내용
을 출력시키고, [stop] 버튼과 [send] 버튼을 활성화시킨다. 서버에서는 클라이언트 연결 수락 내용
과 현재 연결 개수를 출력시킨다.</li>
</ul>

<p>ClientExample.java
ServerExample.java
과제 4
클라이언트에서 글자를 입력하고 [send] 버튼을 클릭하면 입력된 글자는 서버로 전송되고, 서버는 
연결된 모든 클라이언트로 글자를 보내도록 한다. 
ClientExample.java
ServerExample.java</p>

<p>과제 5
클라이언트에서 [stop] 버튼을 클릭하면 [서버 통신 안됨]을 출력하고, [start] 버튼을 활성화, [send] 
버튼을 비활성화시킨다. 서버에서는 클라이언트 통신 안됨으로 출력한다.
ClientExample.java
ServerExample.java</p>



            <!-- Google AdSense -->
<div class="my-4">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3321560028329475"
        crossorigin="anonymous"></script>
</div>
        </div>

        <div class="bd-toc mt-3 mb-5 my-lg-0 ps-xl-3 mb-lg-5 text-body-secondary">

  <button class="btn btn-link p-md-0 mb-2 mb-md-0 text-decoration-none bd-toc-toggle d-md-none" type="button"
    data-bs-toggle="collapse" data-bs-target="#tocContents" aria-expanded="false" aria-controls="tocContents">
    서브목차
    <svg class="bi d-md-none ms-2" aria-hidden="true">
      <use xlink:href="#chevron-expand"></use>
    </svg>
  </button>

  <strong class="d-none d-md-block h6 my-2">서브목차</strong>

  <div class="collapse bd-toc-collapse" id="tocContents">
    <nav id="TableOfContents">
      <!--
      <ul>
        <li><a href="#quick-start">Quick start</a></li>
        <li><a href="#cdn-links">CDN links</a></li>
        <li><a href="#next-steps">Next steps</a></li>
        <li><a href="#js-components">JS components</a></li>
        <li><a href="#important-globals">Important globals</a>
          <ul>
            <li><a href="#html5-doctype">HTML5 doctype</a></li>
            <li><a href="#responsive-meta-tag">Responsive meta tag</a></li>
            <li><a href="#box-sizing">Box-sizing</a></li>
            <li><a href="#reboot">Reboot</a></li>
          </ul>
        </li>
        <li><a href="#community">Community</a></li>
      </ul>
      -->
    </nav>
  </div>
</div>
    </main>
</div>

  <footer class="container">
  <hr class="mt-5 mb-3">
  <div class="row align-items-center pb-3">
    <div class="col-md-6 text-center text-md-start mb-3 mb-md-0">
      <p class="mb-0 text-secondary">Copyright 2017~2026 JinyDev. All Rights Reserved.</p>
    </div>
    <div class="col-md-6 text-center text-md-end">
      
      <a href="https://datas.jiny.dev" class="text-decoration-none text-secondary ms-3">빅데이터</a>
      
      <a href="https://mysql.jiny.dev" class="text-decoration-none text-secondary ms-3">MySQL</a>
      
      <a href="https://php.jiny.dev" class="text-decoration-none text-secondary ms-3">PHP</a>
      
      <a href="https://java.jiny.dev" class="text-decoration-none text-secondary ms-3">자바</a>
      
      <a href="https://git.jiny.dev" class="text-decoration-none text-secondary ms-3">깃&깃허브</a>
      
      <a href="https://linux.jiny.dev" class="text-decoration-none text-secondary ms-3">리눅스</a>
      
    </div>
  </div>
</footer>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN"
    crossorigin="anonymous"></script>
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

    window.addEventListener('load', async function () {
      mermaid.initialize({ startOnLoad: false });

      const mermaidCodes = document.querySelectorAll('pre code.language-mermaid');
      const mermaidDivs = [];

      mermaidCodes.forEach(codeBlock => {
        const mermaidDefinition = codeBlock.textContent.trim();
        const container = codeBlock.closest('div.highlighter-rouge');

        const mermaidDiv = document.createElement('div');
        mermaidDiv.className = 'mermaid';
        mermaidDiv.textContent = mermaidDefinition;

        if (container) {
          container.replaceWith(mermaidDiv);
        } else {
          const pre = codeBlock.parentElement;
          if (pre) pre.replaceWith(mermaidDiv);
        }
        mermaidDivs.push(mermaidDiv);
      });

      if (mermaidDivs.length > 0) {
        await mermaid.run({ nodes: mermaidDivs });
      }
    });
  </script>
  <script src="/assets/js/toc.js"></script>
  <script src="/assets/js/sidebar.js"></script>

</body>

</html>