# 14. 2D 그래픽스

UI 프로그램에서 윈도우 창이나 버튼, 이미지 등은 모두 화면에서 드로잉drawing된 2D 그래픽입니다.

Swing은 개발자가 코드로 2D 그래픽을 드로잉하도록 Java2D API를 제공합니다.


Canvas와 Graphics

손으로 그림을 그리기 위해서는 도화지와 붓이 필요하듯이 Swing에서도 그런 역할을 하는 클래스

가 있습니다. 도화지는 Canvas 클래스이고, 붓은 Graphics 클래스입니다.

Canvas는 최초 드로잉 준비가 되면 paint ( ) 메소

드를 호출해서 Graphics로 드로잉을 합니다. 그리고

다음과 같은 경우에 paint ( ) 메소드를 다시 호출하

도화지
Canvas

여 Graphics로 재 드로잉을 합니다.

Graphics

① 도화지가 축소되었다가 다시 확대했을 때

② 도화지의 크기가 변경되었을 때

③ 도화지가 숨겨졌다가 다시 나타났을 때

다음 예제를 실행해 보면 윈도우 창이 축소되었다가 확대했을 때에 Canvas의 paint ( ) 메소드가 다

시 호출되어 글자를 다시 그리는 것을 볼 수 있습니다. 확인 방법은 콘솔창에서 “paint ( ) 메소드 실행”

이 계속 출력되는 것을 보면 됩니다.

>>> CanvasPaintExample.java


```java
package sec14.exam01_paint;

import java.awt.BorderLayout;
import java.awt.Canvas;
import java.awt.Graphics;
import javax.swing.JFrame;
import javax.swing.SwingUtilities;

public class CanvasPaintExample extends JFrame {
//메인 윈도우 설정
public CanvasPaintExample() {
setTitle("paint() 메소드는 언제 호출될까요?");
```

//사용자 정의 Canvas 객체를 중앙에 배치
getContentPane().add(new MyCanvas(), BorderLayout.CENTER);
setSize(300, 200);




}

//사용자 정의 Canvas 클래스 선언
```java
public class MyCanvas extends Canvas {
public void paint(Graphics g) {
g.drawString("윈도우 창을 줄이거나 늘려보세요", 50, 80);
System.out.println("paint() 메소드 실행");

}

}

public static void main(String[] args) {
SwingUtilities.invokeLater(new Runnable() {
public void run() {
CanvasPaintExample jFrame  =  new CanvasPaintExample();
jFrame.setVisible(true);

}

});

}

}

```

실행 결과

다시 그리기

Canvas에 드로잉하는 작업은 이벤트 디스패칭 스레드가 전담합니다. 이벤트 디스패칭 스레드는 Canvas

의 내용이 갱신될 필요가 있을 때 paint ( ) 메소드를 다시 호출해서 재 드로잉을 합니다. 하지만 개발

자는 paint ( ) 메소드를 직접 호출할 수 없고, 대신 repaint ( ) 메소드를 호출할 수 있습니다.


Canvas의 repaint ( ) 메소드가 호출되면 이벤트 디스패칭 스레드는 update ( ) 메소드를 호출하고

다시 paint ( ) 메소드를 호출해서 재 드로잉을 합니다. update ( ) 메소드의 기본 동작은 paint ( ) 메

소드를 호출하기 전에 이전 화면 내용을 지우는 역할을 합니다.

repaint ( )

update ( )

paint ( )

[이전 화면]

[재 드로잉]

지움

만약 이전 내용을 유지하면서 재 드로잉을 하려면 update ( ) 메소드를 재정의해서 이전 내용을 지

우는 코드를 작성하지 않고 paint (g ) 메소드만 호출하면 됩니다.

```java
public void update(Graphics g) {
paint(g);

}

public void paint(Graphics g) {
//화면 드로잉

…

}
```

다음 예제는 Canvas 위에서 마우스를 누른 상태로 드래그하면 이전 경로에서부터 현재 경로까지

*를 유지하면서 드로잉합니다. 만약 Canvas의 update ( ) 메소드를 재정의하지 않으면 이전 화면을
지우는 update ( )의 기본 기능 때문에 이전 경로의 *는 모두 지워진다.

>>> RepaintExample.java


```java
package sec14.exam02_repaint;

import java.awt.BorderLayout;
import java.awt.Canvas;




import java.awt.Graphics;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionListener;
import javax.swing.JFrame;
import javax.swing.SwingUtilities;

public class RepaintExample extends JFrame {
//메인 윈도우 설정
public RepaintExample() {
setTitle("재 드로잉");
```

//Canvas를 중앙에 배치
getContentPane().add(new MyCanvas(), BorderLayout.CENTER);

setSize(500, 400);

}

//Canvas 클래스 선언
```java
public class MyCanvas extends Canvas implements MouseMotionListener {
private int x;
private int y;

public MyCanvas() {
//MouseMotionListener 추가
addMouseMotionListener(this);

}
```

//Canvas의 update() 재정의
```java
@Override
public void update(Graphics g) {
paint(g);

}
```

//Canvas의 paint() 재정의
```java
@Override
public void paint(Graphics g) {
g.drawString("*", x, y);

}
```

//MouseMotionListener의 mouseDragged() 재정의








//마우스 버튼을 누르고 움직일 때 호출
```java
@Override
public void mouseDragged(MouseEvent e) {
x  =  e.getX();
y  =  e.getY();
```

//Canvas의 repaint() 호출
repaint();

}

//MouseMotionListener의 mouseMoved() 재정의
//마우스 버튼을 누르지 않고 움직일 때 호출
```java
@Override
public void mouseMoved(MouseEvent e) {
System.out.println("aaa");

}

}

public static void main(String[] args) {
SwingUtilities.invokeLater(new Runnable() {
public void run() {
RepaintExample jFrame  =  new RepaintExample();
jFrame.setVisible(true);

}

});

}

}

```

실행 결과






Color와 Font

붓에 물감을 묻혀 그림을 그리듯이 Graphics의 setColor ( ) 메소드로 Color를 설정하면 해당 색

상으로 문자, 선, 도형이 그려진다. 예를 들어 빨간색으로 설정하려면 다음과 같이 합니다.

g.setColor(Color.RED);

Color 클래스는 기본적으로 13가지의 색깔을 표현하는 Color 상수를 가지고 있습니다. 이들 상수를 이

용하면 13가지의 색깔 객체를 쉽게 얻을 수 있습니다.

Color.BLACK

Color.GREEN

Color.WHITE

Color.BLUE

Color.DARK_GRAY

Color.LIGHT_GRAY

Color.MAGENTA

Color.ORANGE

Color.YELLOW

Color.RED

Color.GRAY

Color.CYAN

Color.PINK

13가지 상수 이외의 다른 색상을 얻고 싶다면 R (Red ), G (Green ), B (Blue ) 값을 이용해서

Color 객체를 직접 만들면 됩니다. RGB값은 각각 0~255 사이의 값을 주면 됩니다.

Color color  =  new Color(100, 200, 50);
g.setColor(color);

Graphics의 drawString ( )으로 그려지는 글자의 기본 색상은 검정색이고, 사이즈는 12, 폰트의

종류는 Dialog입니다. Graphics의 setFont ( ) 메소드를 이용하면 폰트 속성을 변경할 수 있습니다. 매

개값은 Font 객체인데, 다음과 같이 생성합니다.

Font font  =  new Font(String name, int style, int size);

name은 폰트 이름으로 굴림체, 돋움체, 바탕체, Arial 등을 말합니다. 폰트는 운영체제마다 차이가

있기 때문에 운영체제에서 제공되는 폰트의 이름을 알아내기 위해 다음 코드를 사용할 수 있습니다.


GraphicsEnvironment ge  =  GraphicsEnvironment.getLocalGraphicsEnvironment();
String[] fontNames  =  ge.getAvailableFontFamilyNames();
for(String fontName : fontNames) {
System.out.println(fontName);

}

style은 폰트 스타일로 보통, 굵음, 기울임을 말합니다. 폰트 스타일은 Font 상수를 사용하는데, 다음

과 같이 세 가지 종류가 있습니다.

Font.PLAIN (보통 글자)

Font.BOLD (굵은 글자)

Font.ITALIC(기울인 글자)

이들 상수는 | 연산자를 사용해서 조합할 수 있습니다. 다음은 돋움체이고, 굵고 기울어지게 15 사이즈로

Font 객체를 만들고 Graphics에 설정합니다.

Font font  =  new Font("돋움체", Font.BOLD | Font.ITALIC, 15);
g.setFont(font);

다음 예제는 Color와 Font를 변경해서 글자를 드로잉하는 방법을 보여 준다.

>>> ColorFontExample.java


```java
package sec14.exam03_color_font;

import java.awt.BorderLayout;
import java.awt.Canvas;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import javax.swing.JFrame;
import javax.swing.SwingUtilities;

public class ColorFontExample extends JFrame {
//메인 윈도우 설정
public ColorFontExample() {
setTitle("색상과 폰트");



getContentPane().add(new MyCanvas(), BorderLayout.CENTER);
setSize(300, 200);

}
```

//Canvas 클래스 선언
```java
public class MyCanvas extends Canvas {
public void paint(Graphics g) {
//Color 변경
g.setColor(Color.BLUE);
//Font 변경
g.setFont(new Font("돋움체", Font.BOLD | Font.ITALIC, 30));
//글자 드로잉
g.drawString("Color and Font", 20, 100);

}

}

public static void main(String[] args) {
SwingUtilities.invokeLater(new Runnable() {
public void run() {
ColorFontExample jFrame  =  new ColorFontExample();
jFrame.setVisible(true);

}

});

}

}

```

실행 결과




기본 도형 그리기

기본 도형에는 선, 원, 타원, 사각형, 호 등이 있습니다. Graphics는 이 기본 도형들을 그리기 위한 메소

드를 다음과 같이 제공합니다.

1) 선을 그리는 메소드

그래픽 좌표 시스템

● drawLine (int x1, int y1, int x2, int y2 )

(0, 0 )

X +

(x1, y1 )

(x2, y2 )

(x, y )

Y +

2) 사각형을 그리는 메소드

width

●  drawRect (int x, int y, int width,

(x, y )

int height )

●  fillRect (int x, int y, int width,

int height )

3) 원 또는 타원을 그리는 메소드

width

●  drawOval (int x, int y, int width,

(x, y )

int height )

●  fillOval (int x, int y, int width,

int height )

4) 모서리가 둥근 사각형을 그리는 메소드

●  drawRoundRect(int x, int y, int width,

(x, y )

int height, int arcWidth, int arcHeight )

●  fillRoundRect (int x, int y, int width,

int height, int arcWidth, int arcHeight )

height

height

arcWidth

arcHeight

height

width



5) 입체 사각형을 그리는 메소드

● draw3DRect (int x, int y, int width, int height, boolean raised )

● fill3DRect (int x, int y, int width, int height, boolean raised )

6) 호를 그리는 메소드

● drawArc (int x, int y, int width, int height, int startAngle, int arcAngle )

● fillArc (int x, int y, int width, int height, int startAngle, int arcAngle )

(x, y )

height

width

arcAngle

startAngle

0도

7) 다각형을 그리는 메소드

● drawPolygon (int[] xPoints, int[] yPoints, int nPoints )

● fillPolygon (int[] xPoints, int[] yPoints, int nPoints )

● drawPolyline (int[] xPoints, int[] yPoints, int nPoints )

8) 영역을 지우는 메소드

● clearRect (int x, int y, int width, int height )

drawXXX ( )와 fillXXX ( )의 차이점은 선만 그리느냐 아니면 내부를 채우느냐입니다.

다음 예제는 Graphics가 제공하는 다양한 메소드를 이용해서 Canvas에 그림을 그린다.

>>> ShapeExample.java


```java
package sec14.exam04_shape;

import java.awt.BorderLayout;
import java.awt.Canvas;




import java.awt.Color;
import java.awt.Graphics;
import javax.swing.JFrame;
import javax.swing.SwingUtilities;

public class ShapeExample extends JFrame {
//메인 윈도우 설정
public ShapeExample() {
setTitle("도형 그리기");
getContentPane().add(new MyCanvas(), BorderLayout.CENTER);
setSize(400,300);

}
```

//Canvas 클래스 선언
```java
public class MyCanvas extends Canvas {
public void paint(Graphics g) {
//원 그리기
g.drawOval(50,50, 50,50);
g.setColor(Color.GREEN);
g.fillOval(50,100, 50,50);
```

//선 그리기
g.setColor(Color.RED);
g.drawLine(50,100, 100,150);
g.drawLine(150,50, 50,150);

//사각형 그리기
g.setColor(Color.BLUE);
g.drawRoundRect(200, 50, 120, 80, 30, 30);
g.setColor(Color.YELLOW);
g.fillRoundRect(250, 100, 120, 80, 30, 30);

//다각형 그리기
g.setColor(Color.ORANGE);
g.fillPolygon(new int[]{50, 100, 150, 200}, new int[]{250, 200, 200,
250}, 4);

//호 그리기
g.setColor(Color.cyan);
g.fillArc(250, 200, 100, 100, 45, 120);






}

}

```java
public static void main(String[] args) {
SwingUtilities.invokeLater(new Runnable() {
public void run() {
ShapeExample jFrame  =  new ShapeExample();
jFrame.setVisible(true);
}
});

}

}

```

실행 결과

안티 알리아싱

비트맵 그래픽의 방식은 작은 사각형(픽셀)을 최소 단위로 하기 때문에 이 픽셀들이 모여 만들어진

원, 곡선, 사선은 경계 부분에서 거친 계단 현상(알리어싱aliasing )이 나타난다. 이 문제를 해결하기 위

해 안티-알리어싱anti-aliasing 기능이 필요하다.

안티알리어싱은 배경색과 이미지 색상의 중간 색상을 단계적으로 채워 경계선을 부드럽게 만들어

주는 기능입니다. 자바는 안티 알리어싱을 위해 Graphics2D의 setRenderingHint ( ) 메소드를 제

공합니다.



paint ( ) 메소드의 매개변수 타입은 Graphics이지만 Graphics2D 객체를 참조하고 있기 때문에

다음과 같이 타입 변환을 통해 Graphics2D 객체를 얻고 setRenderingHint ( ) 메소드를 호출할

수 있습니다.

```java
public void paint(Graphics g) {
Graphics2D g2  =  (Graphics2D) g;
g2.setRenderingHint(
RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

...

}
```

Java 2D는 여러 가지 렌더링 알고리즘을 키와 값으로 구성된 맵Map 객체로 관리하고 있습니다. 안티 알

리아싱 기능을 활성화할지 여부의 값은 RenderingHints.KEY_ANTIALIASING 키로 관리하고

있기 때문에 이 키의 값을 RenderingHints.VALUE_ANTIALIAS_ON으로 변경하면 됩니다.

다음 예제는 안티 알리아싱을 적용하지 않은 원과 적용한 원의 차이점을 보여 준다.

>>> AntiAliasingExample.java


```java
package sec14.exam05_antialiasing;

import java.awt.BorderLayout;
import java.awt.Canvas;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import javax.swing.JFrame;
import javax.swing.SwingUtilities;

public class AntiAliasingExample extends JFrame {
//메인 윈도우 설정
public AntiAliasingExample() {
setTitle("안티알리아싱");
getContentPane().add(new MyCanvas(), BorderLayout.CENTER);
setSize(200,350);

}
```

//Canvas 클래스 선언



```java
public class MyCanvas extends Canvas {
public void paint(Graphics g) {
//안티알리어싱을 적용하지 않은 원
g.fillOval(50, 50, 100, 100);
```

//안티알리어싱을 적용한 원
Graphics2D g2  =  (Graphics2D) g;
g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
RenderingHints.VALUE_ANTIALIAS_ON);
g.fillOval(50, 200, 100, 100);

}

}

```java
public static void main(String[] args) {
SwingUtilities.invokeLater(new Runnable() {
public void run() {
AntiAliasingExample jFrame  =  new AntiAliasingExample();
jFrame.setVisible(true);

}

});

}

}


```

실행 결과





이미지 그리기

이미지를 드로잉하기 위해서는 이미지 파일을 메모리로 로딩해서 Image 객체를 얻어야 합니다. Image

객체를 얻는 방법은 두 가지가 있는데, 첫 번째로는 Toolkit의 getImage ( ) 메소드로 얻을 수 있습니다.

Toolkit toolkit  =  Toolkit.getDefaultToolkit();
//파일 시스템의 이미지 경로를 가지고 있을 경우
Image image1  =  toolkit.getImage(String filename);
//파일 시스템 또는 인터넷의 이미지 URL을 가지고 있을 경우
Image image2  =  toolkit.getImage(URL url);

두 번째 방법은 ImageIcon 객체를 생성해서 getImage ( ) 메소드로 얻을 수 있습니다.

//파일 시스템의 이미지 경로를 가지고 있을 경우
ImageIcon imageIcon1  =  new ImageIcon(String filename);
Image image1  =  imageIcon1.getImage();

//파일 시스템 또는 인터넷의 이미지 URL을 가지고 있을 경우
ImageIcon imageIcon2  =  new ImageIcon(URL url);
Image image2  =  imageIcon2.getImage();

URL을 생성하는 방법은 다음과 같다.

//파일 시스템의 이미지 경로를 가지고 있을 경우
URL url  =  new URL("file:///C:\images\logo.gif");

//클래스 파일과 동일한 디렉토리에 있는 이미지 파일일 경우
URL url  =  getClass().getResource("logo.gif");

//인터넷의 이미지 URL을 가지고 있을 경우
URL url  =  new URL("http://www.naver.com/logo.gif");

두 가지 방법을 이용해서 Image 객체를 얻었다면 이미지를 Canvas에 드로잉할 수 있는데, 다음과

같이 Graphics의 drawImage ( ) 메소드를 이용합니다. img는 Image 객체이고, x와 y는 드로잉이

시작될 좌상단 좌표입니다.



drawImage(Image img, int x, int y, ImageObserver observer)

observer는 이미지 로딩과 드로잉을 동시에 할 때 필요하다. 이미지를 로딩하는 도중에 주기

적으로 ImageObserver의 imageUpdate ( ) 메소드가 호출되는데, 이 메소드는 Canvas의

repaint ( ) 메소드를 호출해서 그때까지 로딩된 이미지를 다시 그리도록 합니다. Canvas는 기본적으

로 ImageObserver 인터페이스를 구현하고 있기 때문에 this를 사용해서 observer의 매개값으로

줄 수 있다

다음 예제는 ImageExample 클래스와 동일한 위치에 있는 이미지 파일을 읽고, Canvas에 드로

잉하는 방법을 보여 준다.

>>> ImageExample.java


```java
package sec14.exam06_image;

import java.awt.BorderLayout;
import java.awt.Canvas;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Toolkit;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.SwingUtilities;

public class ImageExample extends JFrame {
//메인 윈도우 설정
public ImageExample() {
setTitle("이미지 그리기");
getContentPane().add(new MyCanvas(), BorderLayout.CENTER);
add(new MyCanvas(), BorderLayout.CENTER);
setSize(500,350);

}
```

//Canvas 클래스 선언
```java
public class MyCanvas extends Canvas {
private Image imgSun, imgMoon;;


public MyCanvas() {
//배경색을 흰색으로 변경
setBackground(Color.WHITE);
```

//이미지를 로딩해서 읽고, Image 객체 얻기
Toolkit toolkit  =  Toolkit.getDefaultToolkit();
imgSun  =  toolkit.getImage(getClass().getResource("sun.gif"));
imgMoon = new ImageIcon(getClass().getResource("moon.gif")).getImage();

}

```java
public void paint(Graphics g) {
//이미지 드로잉
g.drawImage(imgSun, 10, 10, this);
g.drawImage(imgMoon, 300, 20, this);

}

}

public static void main(String[] args) {
SwingUtilities.invokeLater(new Runnable() {
public void run() {
ImageExample jFrame  =  new ImageExample();
jFrame.setVisible(true);

}

});

}

}

```

실행 결과







배경 이미지 넣기

JPanel에 배경 이미지를 넣는 방법을 알아보자. JPanel은 paint ( ) 메소드를 실행할 때 자신의

paintComponent ( ) 메소드를 먼저 호출하고, 자식 컴포넌트의 paint ( ) 메소드를 나중에 호출하

도록 되어 있습니다. 배경 그림은 모든 자식 컴포넌트보다 먼저 드로잉되어 자식 컴포넌트 밑에 깔려야

하므로 paintComponent ( )에서 배경 그림이 드로잉되어야 합니다.

JPanel

① paint ( )

② paintComponent ( )

JTextField

③ paint ( )

JButton

④ paint ( )

다음 예제는 JPanel에 배경 이미지를 드로잉해서 JTextField와 JButton가 배경 이미지 위에 배치

되도록 합니다.

>>> BackgroundImageExample.java


```java
package sec14.exam07_background_image;

import java.awt.BorderLayout;
import java.awt.Graphics;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;

public class BackgroundImageExample extends JFrame {
private JTextField txtId;
private JButton btnLogin;


```

//메인 윈도우 설정
public BackgroundImageExample() {
this.setTitle("배경 그림 넣기");
this.getContentPane().add(new MyPanel(), BorderLayout.CENTER);
this.setSize(200, 270);
this.setResizable(false);
this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

}

//JPanel 클래스 선언
```java
public class MyPanel extends JPanel {
public MyPanel() {
setLayout(null);
//JTextField와 JButton 부착
add(getTextField());
add(getButton());

}

@Override
public void paintComponent(Graphics g)  {
//배경 그리기
ImageIcon icon = new ImageIcon(this.getClass().getResource("bg.jpg"));
g.drawImage(icon.getImage(), 0, 0, this);

}

}
```

//JTextField 생성
public JTextField getTextField() {
if(txtId  = =  null) {
txtId  =  new JTextField();
txtId.setBounds(50, 50, 100, 30);

}
return txtId;

}

//JButton 생성
public JButton getButton() {
if(btnLogin  = =  null) {
btnLogin  =  new JButton("버튼");









btnLogin.setBounds(50, 100, 100, 30);

}
return btnLogin;

}

```java
public static void main(String[] args) {
SwingUtilities.invokeLater(new Runnable() {
public void run() {
BackgroundImageExample jFrame  =  new BackgroundImageExample();
jFrame.setVisible(true);

}

});

}

}

```

실행 결과

