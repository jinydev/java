# 05. 이벤트 처리

UI 프로그램은 사용자와 상호작용을 하면서 코드를 실행합니다. 사용자가 UI의 컴포넌트를 사용하는

순간 이벤트event가 발생하고, 프로그램은 이벤트를 처리하기 위해 코드를 실행합니다.




자바는 이벤트 소스 객체(컨테이너, 컴포넌트)와 이벤트 처리 객체(리스너Listener )를 분리하는 위임

형Delegation 방식을 사용합니다. 위임형 방식이란 이벤트 소스에서 이벤트가 발생하면 직접 처리하지 않

고 이벤트 소스에 추가된 리스너에게 이벤트 처리를 위임하는 방식입니다.

예를 들어 사용자가 JButton (이벤트 소스 객체)를 클릭하면 액션 이벤트ActionEvent가 발생하고,

JButton에 추가된 ActionLister 객체(이벤트 처리 객체)가 액션 이벤트를 처리합니다.

이벤트 소스 객체
(JButton )

①

② 이벤트
발생

이벤트 처리 객체
(ActionListener )

이벤트 처리 메소드
실행

④ 이벤트 처리 효과

actionPerformed(…) {

1. 윈도우 닫기
2. 윈도우 내용 변경,
3. 새로운 윈도우 띄우기

}

③ 이벤트 처리

이벤트 처리 객체인 리스너는 컴포넌트에서 이벤트가 발생하면 이벤트 처리 메소드를 실행시킵니다.

이벤트 처리 메소드는 현재 윈도우를 닫거나, 윈도우 내용을 변경하거나, 새로운 윈도우 또는 다이

얼로그를 띄우기도 합니다.

컴포넌트는 하나의 이벤트만 발생하는 것이 아니라 동시에 여러 개의 이벤트가 발생하기도 합니다. 예

를 들어 JButton을 마우스로 클릭하면 액션 이벤트ActionEvent와 함께 마우스 이벤트MouseEvent도 발생

합니다. 액션 이벤트는 마우스로 클릭하거나 Enter 키를 눌러 사용하는 컴포넌트에서 주로 발생하고,

마우스 이벤트는 대부분의 컨테이너 또는 컴포넌트에서 발생합니다.

컴포넌트에서 발생하는 모든 이벤트를 처리하기 위해서는 이벤트별로 리스너가 추가되어야 합니다.

JButton에서 발생하는 액션 이벤트와 마우스 이벤트를 동시에 처리하기 위해서는 액션 리스너와

마우스 리스너가 모두 필요하다.

하지만, 동시에 발생되는 이벤트가 많다고 하더라도 모두 처리할 필요가 없습니다. 처리하고 싶은 관심

이벤트에 대해서만 리스너를 추가하면 됩니다. 다음 표는 컨테이너 및 컴포넌트에서 발생할 수 있는

대표적인 이벤트와 이벤트 처리 리스너를 정리한 표입니다.



이벤트 소스

발생 이벤트

발생 원인

리스너

JFrame

JDialog

WindowEvent

WindowEvent

중 하나를 클릭했을 때

WindowListener

중 하나를 클릭했을 때

WindowListener

JTextField

ActionEvent

Enter  키를 눌렀을 때

JButton

ActionEvent

JRadioButton

ActionEvent

JCheckBox

ActionEvent

JMenuItem

ActionEvent

클릭했을 때

클릭했을 때

클릭했을 때

선택했을 때

ActionListener

ActionListener

ActionListener

ActionListener

ActionListener

JComboBox

ActionEvent

다른 항목을 선택했을 때

ActionListener

JList

ListSelectionEvent

다른 항목을 선택했을 때

ListSelectionListener

이벤트 소스에 리스너를 추가하려면 addXXXListener ( ) 메소드를 사용합니다. XXX는 이벤트명인

데, 예를 들어 WindowEvent, ActionEvent, ListSelectionEvent를 처리하기 위한 리스너를 추

가하는 메소드는 다음과 같다.

jFrame.addWindowListener(WindowListener listener);
jButton.addActionListener(ActionListener listener);
jList.addListSelectionListener(ListSelectionListener listener);

자바 API 도큐먼트를 보면 컴포넌트에서 어떤 이벤트들이 발생하는지 알 수 있습니다. 컴포넌트의

메소드 목록을 보면 addXXXListener ( ) 메소드를 많이 볼 수 있습니다. 이것은 해당 컴포넌트가

XXXEvent가 발생할 수 있으니 XXXListener를 등록할 수 있다는 말입니다.

대부분의  컴포넌트들은  java.awt.Component를  상속하는데,  Component  클래스는

addKeyListener ( )와 addMouseListener ( ) 메소드를 가지고 있습니다. 따라서 KeyEvent와

MouseEvent가 발생할 수 있고, 이들을 처리하기 위해 KeyListener와 MouseListener를 등록할

수 있습니다.

Listener와 Adapter

컴포넌트에 리스너를 추가하기 위해서는 리스너 클래스를 먼저 작성해야 합니다. 리스너 클래스를 생

성하는 방법은 리스너 인터페이스를 구현하는 방법과 어댑터 클래스를 상속하는 방법이 있습니다.



XXXListener (인터페이스)

implements

XXXAdapter (클래스)

implements

extends

사용자 리스너 클래스

리스너 인터페이스를 구현하는 방법

리스너 인터페이스를 구현하려면 리스너 인터페이스에 정의되어 있는 이벤트 처리 메소드를 모두

재정의해야 합니다.

예를 들어 WindowListener에는 windowClosing ( ) 메소드를 포함하여 7개의 메소드가 정의

되어 있습니다. 이 메소드들은 WindowEvent가 발생했을 때 사용자의 행위에 따라 개별적으로 실행

됩니다. 윈도우 상단 우측 닫기(×) 버튼을 클릭하면 windowClosing ( ) 메소드가 실행되고, 최소

화(_) 버튼을 클릭하면 windowIconified ( ) 메소드가 실행됩니다. 닫기(×) 버튼에서 발생하는

WindowEvent만 처리하고 싶어도 windowClosing ( ) 및 나머지 6개를 다음과 같이 모두 재정

의해야 합니다.

```java
class MyWindowListener implements WindowListener {
public void windowActivated(WindowEvent e) {}
public void windowClosed(WindowEvent e) {}
public void windowClosing(WindowEvent e) {
//닫기(x) 버튼을 클릭했을 때 처리 방법 코딩

}

public void windowDeactivated(WindowEvent e) {}
public void windowDeiconified(WindowEvent e) {}
public void windowIconified(WindowEvent e) {}
public void windowOpened(WindowEvent e) {}

}


```

리스너 어댑터를 상속하는 방법

리스너 어댑터를 상속하면 관심 있는 이벤트 처리 메소드만 재정의할 수 있기 때문에 리스너 인터페

이스를 구현하는 방법보다 좀 더 효율적입니다.

예를 들어 WindowAdapter 클래스를 상속할 경우 windowClosing ( ) 메소드만 재정의하면 된

다. 나머지 6개의 메소드는 WindowAdapter에서 내용이 없는 채로 이미 구현되어 있기 때문입니다.

```java
class MyWindowListener extends WindowAdapter {
public void windowClosing(WindowEvent e) {
//닫기(x) 버튼을 클릭했을 때 처리 방법 코딩

}

}
```

리스너 인터페이스에 대응되는 어댑터 클래스가 모두 존재하는 것은 아니다. 리스너 인터페이스에 2개

이상의 이벤트 처리 메소드가 정의되어 있을 경우에만 어댑터 클래스가 제공됩니다. ActionEvent

를 처리하는 ActionListener일 경우 actionPerformed ( ) 메소드 한 개만 정의되어 있기 때문에

ActionAdapter는 제공되지 않는다. 다음 표는 리스너 인터페이스와 대응되는 어댑터 클래스를 나

타낸 것입니다.

리스너 인터페이스

어댑터

java.awt.event.WindowListener

java.awt.event.WindowAdapter

java.awt.event.MouseListener

java.awt.event.MouseAdapter

java.awt.event.KeyListener

java.awt.event.KeyAdapter

java.awt.event.ActionListener

javax.swing.event.ListSelectionListener

없음

없음

다음 예제는 JFrame의 제목 표시줄의 닫기(×) 버튼과 하단에 있는 btnClose 버튼 중 하나를 클

릭하면 프로그램이 종료되도록 합니다. 제목 표시줄의 닫기 버튼은 WindowAdapter를, btnClose

는 ActionListener를 이용해서 리스너 클래스를 작성하였다.



>>> ClosableExample1.java


```java
package sec05.exam01_windowadpater;

import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.SwingUtilities;

public class ClosableExample1 extends JFrame {
private JButton btnClose;
```

//메인 윈도우 설정
public ClosableExample1() {
this.setTitle("CloseExample");
this.setSize(300, 100);

this.setLayout(new FlowLayout());
this.getContentPane().add(getBtnClose());

//WindowListener 추가
this.addWindowListener(new MyWindowAdapter());

}

//닫기 버튼 생성
private JButton getBtnClose() {
if(btnClose  = =  null) {
btnClose  =  new JButton();
btnClose.setText("닫기");

//ActionListener 추가
btnClose.addActionListener(new MyActionListener());

}
return btnClose;

}

```java
public static void main(String[] args) {









SwingUtilities.invokeLater(new Runnable() {
public void run() {
ClosableExample1 jFrame  =  new ClosableExample1();
jFrame.setVisible(true);
}

});

}

}
```

//WindowAdapter 클래스를 상속해서 WindowListener 클래스 작성
```java
class MyWindowAdapter extends WindowAdapter {
@Override
public void windowClosing(WindowEvent e) {
System.exit(0);

}

}
```

//ActionListener를 구현해서 ActionListener 클래스 작성
```java
class MyActionListener implements ActionListener {
@Override
public void actionPerformed(ActionEvent e) {
System.exit(0);

}

}

```

실행 결과

Anonymous Listener

이벤트를 처리할 때 리스너 클래스를 외부 클래스로 선언하게 되면 컨테이너의 필드와 메소드에 접

근하는 것이 불편하다. 그래서 리스너는 일반적으로 익명Anonymous 객체로 작성합니다. 다음 예제는 이

전 예제를 수정한 것으로, 익명 객체를 사용해서 이벤트를 처리합니다.



>>> ClosableExample2.java


```java
package sec05.exam01_windowadpater;

import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.SwingUtilities;

public class ClosableExample2 extends JFrame {
private JButton btnClose;
```

//메인 윈도우 설정
public ClosableExample2() {
this.setTitle("CloseExample");
this.setSize(300, 100);

this.setLayout(new FlowLayout());
this.getContentPane().add(getBtnClose());

//익명 WindowListener 객체 추가
this.addWindowListener(new WindowAdapter() {
```java
@Override
public void windowClosing(WindowEvent e) {
System.exit(0);

}

});

}

private JButton getBtnClose() {
if(btnClose  = =  null) {
btnClose  =  new JButton();
btnClose.setText("닫기");
```

//익명 ActionListener 객체 추가








btnClose.addActionListener(new ActionListener() {
```java
@Override
public void actionPerformed(ActionEvent e) {
System.exit(0);

}

});

}
return btnClose;

}

public static void main(String[] args) {
SwingUtilities.invokeLater(new Runnable() {
public void run() {
ClosableExample2 jFrame  =  new ClosableExample2();
jFrame.setVisible(true);

}

});

}

}

```

실행 결과

만약 복수 개의 컴포넌트에서 동일한 리스너를 사용해서 이벤트를 처리하고 싶다면 리스너를 필드

로 선언합니다. 이 경우에는 리스너에서 어떤 컴포넌트에서 이벤트가 발생되었는지 코드로 구분해야

합니다.

다음 예제는 두 개의 JButton에서 발생하는 ActionEvent를 하나의 ActionListener 익명 객체

로 처리하는 방법을 보여 준다. 어떤 컴포넌트에서 ActionEvent가 발생되었는지 구분하기 위해

ActionEvent의 getSource ( ) 메소드를 이용하였다.




>>> ActionListenerExample.java


```java
package sec05.exam02_actionlistener;

import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.SwingUtilities;

public class ActionListenerExample extends JFrame {
private JButton btnOk;
private JButton btnCancel;
```

//메인 윈도우 설정
public ActionListenerExample() {
this.setTitle("ActionListenerExample");
this.setSize(300, 100);
this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

this.setLayout(new FlowLayout());
this.getContentPane().add(getBtnOk());
this.getContentPane().add(getBtnCancel());

}

//ActionListener 타입의 필드 선언 및 익명 객체로 초기화
private ActionListener actionListener  =  new ActionListener() {
```java
@Override
public void actionPerformed(ActionEvent e) {
//ActionEvent가 발생한 컴포넌트 구분
if(e.getSource()  = =  btnOk) {
System.out.println("확인 버튼을 클릭했습니다.");
} else if(e.getSource()  = =  btnCancel) {
System.out.println("취소 버튼을 클릭했습니다.");

}

}

};
```

//Ok 버튼 생성








private JButton getBtnOk() {
if(btnOk  = =  null) {
btnOk  =  new JButton();
btnOk.setText("확인");
//actionListener 필드 대입
btnOk.addActionListener(actionListener);

}
return btnOk;

}

//Cancel 버튼 생성
private JButton getBtnCancel() {
if(btnCancel  = =  null) {
btnCancel  =  new JButton();
btnCancel.setText("취소");
//actionListener 필드 대입
btnCancel.addActionListener(actionListener);

}
return btnCancel;

}

```java
public static void main(String[] args) {
SwingUtilities.invokeLater(new Runnable() {
public void run() {
ActionListenerExample jFrame  =  new ActionListenerExample();
jFrame.setVisible(true);

}

});

}

}

```

실행 결과




