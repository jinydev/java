---
layout: part01
title: "3.9 비트 이동 연산자"
nav_order: 9
parent: "Chapter 03. 연산자"
grand_parent: "객체지향 자바 프로그래밍"
---

# 3.9 비트 이동 연산자

비트 이동 연산자는 비트를 좌측 또는 우측으로 밀어서 이동시키는 연산을 수행한다.

| 구분      | 연산식    | 설명                                                                                   |
| :-------- | :-------- | :------------------------------------------------------------------------------------- |
| 좌측 이동 | `a << b`  | 정수 a의 각 비트를 b만큼 왼쪽으로 이동(빈자리는 0으로 채움)                            |
| 우측 이동 | `a >> b`  | 정수 a의 각 비트를 b만큼 오른쪽으로 이동(빈자리는 최상위 부호 비트와 같은 값으로 채움) |
|           | `a >>> b` | 정수 a의 각 비트를 b만큼 오른쪽으로 이동(빈자리는 0으로 채움)                          |

`a << b` 연산은 `a * 2^b`와 같은 결과를 산출하고, `a >> b` 연산은 `a / 2^b`와 같은 결과를 산출한다.

**[예제: BitShiftExample1.java]**
```java
package ch03.sec09;

public class BitShiftExample1 {
    public static void main(String[] args) {
        int num1 = 1;
        int result1 = num1 << 3;
        int result2 = num1 * (int) Math.pow(2, 3);
        System.out.println("result1: " + result1);
        System.out.println("result2: " + result2);
        
        int num2 = -8;
        int result3 = num2 >> 3;
        int result4 = num2 / (int) Math.pow(2, 3);
        System.out.println("result3: " + result3);
        System.out.println("result4: " + result4);
    }
}
```

**실행 결과**
```
result1: 8
result2: 8
result3: -1
result4: -1
```

이번에는 우측 이동 연산자(`>>>`)를 사용하여 정수 -8을 3비트만큼 오른쪽으로 이동시켜 보자.

```java
int result = -8 >>> 3;
//00011111 11111111 11111111 11111111 (536870911)
```

32비트 전체를 오른쪽으로 3비트 이동할 때 맨 오른쪽 3비트는 밀려서 버려지고, 맨 왼쪽에 새로 생기는 3비트는 무조건 0으로 채워진다. 이렇게 변환된 2진수를 10진수로 변환하면 536870911 값을 얻는다.

다음은 `int` 타입 값 772를 구성하는 4개의 `byte`를 각각 별도로 읽고, 부호 없는 정수(0~255)로 출력하는 예제이다.

**[예제: BitShiftExample2.java]**
```java
package ch03.sec09;

public class BitShiftExample2 {
    public static void main(String[] args) {
        int value = 772; // [00000000] [00000000] [00000011] [00000100]
        
        //우측으로 3byte(24bit) 이동하고 끝 1바이트만 읽음: [00000000]
        byte byte1 = (byte) (value >>> 24);
        int int1 = byte1 & 255;
        System.out.println("첫 번째 바이트 부호 없는 값: " + int1);
        
        //우측으로 2byte(16bit) 이동하고 끝 1바이트만 읽음: [00000000]
        byte byte2 = (byte) (value >>> 16);
        int int2 = Byte.toUnsignedInt(byte2);
        System.out.println("두 번째 바이트 부호 없는 값: " + int2);
        
        //우측으로 1byte(8bit) 이동하고 끝 1바이트만 읽음: [00000011]
        byte byte3 = (byte) (value >>> 8);
        int int3 = byte3 & 255;
        System.out.println("세 번째 바이트 부호 없는 값: " + int3);
        
        //끝 1바이트만 읽음: [00000100]
        byte byte4 = (byte) value;
        int int4 = Byte.toUnsignedInt(byte4);
        System.out.println("네 번째 바이트 부호 없는 값: " + int4);
    }
}
```

**실행 결과**
```
첫 번째 바이트 부호 없는 값: 0
두 번째 바이트 부호 없는 값: 0
세 번째 바이트 부호 없는 값: 3
네 번째 바이트 부호 없는 값: 4
```
