# 04. 컴포넌트 배치

컨테이너에는 UI 컴포넌트들이 배치됩니다. 대표적인 컴포넌트에는 버튼, 체크박스, 라디오 버튼, 콤

포, 리스트 등이 있습니다. 컨테이너는 기본적으로 배치 관리자로 컴포넌트를 배치합니다.

배치 관리자는 좌표값으로 컴포넌트를 배치하지 않고, 컨테이너를 몇 개의 구획으로 나누어 하나의

구획에 하나의 컴포넌트를 배치해준다. 배치 관리자로 배치하게 되면 컨테이너의 크기가 사용자에

의해 변경되더라도 컴포넌트의 크기가 비율적으로 늘거나 줄게되어 배치 모양이 그대로 유지된다는

장점이 있습니다.

크기가 고정된 컨테이너일 경우, 세밀한 배치를 위해서 좌표값으로 컴포넌트를 배치할 수도 있습니다.




이 경우 컨테이너의 좌측 상단 모서리를  (0,0 )으로 보고, x축과 y축 좌표로 컴포넌트의 위치를 정

해서 배치합니다.

Layout Manager

컨테이너가 컴포넌트를 배치할 때에는 배치 관리자Layout Manager가 무엇이냐에 따라 달라진다.

JWindow, JFrame, JDialog는 기본적으로 BorderLayout 배치 관리자를 사용하고, JPanel은

FlowLayout을 사용합니다. 자바는 java.awt 패키지에서 다음과 같은 배치 관리자를 제공합니다.

배치 관리자

설명

BorderLayout

동·서·남·북·중앙으로 컴포넌트를 배치

CardLayout

FlowLayout

GridLayout

여러 장의 카드에 컴포넌트를 각각 배치

왼쪽에서 오른쪽으로 컴포넌트를 배치

바둑판과 같은 격자에 컴포넌트를 배치

GridBagLayout

바둑판과 같은 격자에 컴포넌트를 배치하지만 격자 간 병합 가능

컨테이너의 기본 배치 관리자 대신 다른 것을 사용하고 싶다면 setLayout ( ) 메소드로 변경할 수 있

다. setLayout ( )의 매개변수 데이터 타입은 LayoutManager 인터페이스인데, 모든 배치 관리자

의 인스턴스가 올 수 있습니다. 다음은 JFrame의 배치 관리자를 변경하는 방법을 보여 준다.

jFrame.getContentPane().setLayout( LayoutManager layoutManager );

new BorderLayout ( )

new FlowLayout ( )

new GridLayout (2,3 )

컨테이너의 배치 관리자 설정은 컴포넌트를 배치하기 전에 변경하는 것이 좋다. 컨테이너에서 사용

하는 배치 관리자를 얻고 싶다면 컨테이너의 getLayout ( ) 메소드를 호출하면 됩니다. getLayout ( )

의 리턴타입은 LayoutManager 인터페이스이므로 다음과 같이 타입 변환을 해야 합니다.

BorderLayout borderLayout  =  (BorderLayout) jFrame.getContentPane().getLayout();



BorderLayout

BorderLayout 배치 관리자는 컨테이너를 중앙·

동·서·남·북으로 구획 짓고, 각 구획에 하나의

컴포넌트 또는 컨테이너를 배치합니다. 일반적으로

각 구획에는 JPanel 컨테이너가 배치되어 복잡한

형태의 UI를 만들어낸다. 다음 그림은 JFrame의

각 구획에 JButton 컴포넌트를 배치한 것입니다.

BorderLayout을 기본적으로 사용하는 컨테이너

는 JWindow, JFrame, JDialog 등이 있습니다. BorderLayout이 적용된 컨테이너에 컴포넌트를 배

치할 때에는 다음과 같이 ContentPane을 얻고 add ( ) 메소드를 사용해야 합니다.

jFrame.getContentPane().add(컴포넌트, BorderLayout.CENTER);
jFrame.getContentPane().add(컴포넌트, BorderLayout.EAST);
jFrame.getContentPane().add(컴포넌트, BorderLayout.WEST);
jFrame.getContentPane().add(컴포넌트, BorderLayout.SOUTH);
jFrame.getContentPane().add(컴포넌트, BorderLayout.NORTH);

첫 번째 매개값에는 배치할 컴포넌트 객체가 오고, 두 번째 매개값에는 어떤 구획에 배치할 것인지

지정하는 BorderLayout의 상수가 온다. 만약 동·서·남·북 중에서 컴포넌트가 배치되지 않은

구획이 있다면 중앙에 배치된 컴포넌트가 해당 구획까지 확장됩니다.

다음 예제는 중앙, 북쪽, 남쪽에만 컴포넌트를 배치하고, 동쪽과 서쪽은 배치하지 않았다. 그래서 중

앙에 배치된 컴포넌트가 동쪽과 서쪽으로 확장되었다.

>>> BorderLayoutExample.java


```java
package sec04.exam01_borderlayout;

import java.awt.BorderLayout;
import java.awt.Color;
import javax.swing.JButton;
import javax.swing.JFrame;




import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;

public class BorderLayoutExample extends JFrame {
private JTextField txtNorth;
private JTextArea txtCenter;
private JButton btnSouth;
```

//메인 윈도우 설정
public BorderLayoutExample() {
this.setTitle("BorderLayoutExample");
this.setSize(300, 200);
this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

//북쪽, 중앙, 남쪽에 컴포넌트 배치
this.getContentPane().add(getTxtNorth(), BorderLayout.NORTH);
this.getContentPane().add(getTxtCenter(), BorderLayout.CENTER);
this.getContentPane().add(getBtnSouth(), BorderLayout.SOUTH);

}

//JTextField 생성
private JTextField getTxtNorth() {
if (txtNorth  = =  null) {
txtNorth  =  new JTextField();
txtNorth.setText("북쪽 컴포넌트");
txtNorth.setBackground(Color.YELLOW);

}
return txtNorth;

}

//JTextArea 생성
private JTextArea getTxtCenter() {
if (txtCenter  = =  null) {
txtCenter  =  new JTextArea();
txtCenter.append("중앙 컴포넌트\n");
txtCenter.append("동쪽 컴포넌트가 없으니 동쪽으로 확장\n");
txtCenter.append("서쪽 컴포넌트가 없으니 서쪽으로 확장\n");

}
return txtCenter;



}

//JButton 생성
private JButton getBtnSouth() {
if (btnSouth  = =  null) {
btnSouth  =  new JButton();
btnSouth.setText("남쪽 컴포넌트");

}
return btnSouth;

}

```java
public static void main(String[] args) {
SwingUtilities.invokeLater(new Runnable() {
public void run() {
BorderLayoutExample jFrame  =  new BorderLayoutExample();
jFrame.setVisible(true);

}

});

}

}

```

실행 결과

FlowLayout

FlowLayout 배치 관리자는 이미 배치된 컴포넌트의 오른쪽 옆에 새로운 컴포넌트를 배치합니다. 오

른쪽에 배치할 공간이 부족하면 하단에 배치하기 때문에 사용자에 의해 컨테이너의 폭width이 변경되

면 컴포넌트의 배치 위치가 변경될 수 있습니다.



FlowLayout이 적용된 컨테이너에 컴포넌트를 배치할 때는 컴포넌트만 매개변수로 갖는 add ( )

메소드를 사용합니다. 예를 들어 JFrame이 FlowLayout을 사용하여 컴포넌트를 배치한다면, 다음

과 같은 add ( ) 메소드로 컴포넌트를 배치합니다.

jFrame.getContentPane().setLayout(new FlowLayout());
jFrame.getContentPane().add(컴포넌트);

다음 예제는 JFrame의 배치 관리자로 FlowLayout을 적용하고 버튼 두 개를 배치한 것입니다.

>>> FlowLayoutExample.java


```java
package sec04.exam02_flowlayout;

import java.awt.FlowLayout;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.SwingUtilities;

public class FlowLayoutExample  extends JFrame {
private JButton btnOk;
private JButton btnCancel;
```

//메인 윈도우 설정
public FlowLayoutExample() {
this.setTitle("FlowLayoutExample");
this.setSize(300, 100);
this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

//FlowLayout으로 변경하고 두 개의 버튼 추가
this.setLayout(new FlowLayout());
this.getContentPane().add(getBtnOk());
this.getContentPane().add(getBtnCancel());






}

//Ok 버튼 생성
private JButton getBtnOk() {
if(btnOk  = =  null) {
btnOk  =  new JButton();
btnOk.setText("확인");

}
return btnOk;

}

//Cancel 버튼 생성
private JButton getBtnCancel() {
if(btnCancel  = =  null) {
btnCancel  =  new JButton();
btnCancel.setText("취소");

}
return btnCancel;

}

```java
public static void main(String[] args) {
SwingUtilities.invokeLater(new Runnable() {
public void run() {
FlowLayoutExample jFrame  =  new FlowLayoutExample();
jFrame.setVisible(true);

}

});

}

}

```

실행 결과

FlowLayout을 기본적으로 사용하는 컨테이너에는 JPanel이 있습니다. JPanel은 JWindow,

JFrame, JDialog처럼 하나의 윈도우 창을 만들는 최상위 레벨 컨테이너가 아니라, 컨테이너 속에서





컴포넌트의 배치를 위해 사용되는 투명한 보조 컨테이너입니다.

다음은 JFrame 남쪽에 JPanel을 추가하고, JPanel 내부에 JButton 두 개를 배치한 것입니다.

JPanel

JPanel은 컴포넌트가 배치될 수 있는 어떤 곳이라도 배치가 가능하다. 심지어 JPanel에 또다른

JPanel을 배치하는 것도 가능하다. JPanel은 기본적으로 FlowLayout을 사용하지만, 다음과 같이

setLayout ( ) 메소드로 배치 관리자를 변경할 수도 있습니다.

JPanel jPanel  =  new JPanel();
jPanel.setLayout(new BorderLayout());

JPanel은 JWindow, JFrame, JDialog처럼 Root Pane을 이용해서 컴포넌트를 관리하지 않기

때문에 ContentPane이 없이 JPanel의 add ( ) 메소드로 컴포넌트를 배치하면 됩니다.

FlowLayout일 경우:   jPanel.add(컴포넌트);
BorderLayout일 경우:  jPanel.add(컴포넌트, BorderLayout.CENTER);

JPanel을 사용하지 않고 JFrame, JDialog에서 복잡한 형태로 컴포넌트를 배치할 수 없기 때문에

거의 필수적으로 JPanel이 사용됩니다. 다음 예제는 JFrame의 남쪽에 JPanel을 배치하고 확인 및

취소 버튼을 JPanel에 배치합니다.



>>> JPanelExample.java


```java
package sec04.exam03_jpanel;

import java.awt.BorderLayout;
import java.awt.Color;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;

public class JPanelExample extends JFrame {
private JPanel panelSouth;
private JButton btnOk;
private JButton btnCancel;
```

//메인 윈도우 설정
public JPanelExample() {
this.setTitle("JPanelExample");
this.setSize(250, 200);
this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
//남쪽에 JPanel 추가
this.getContentPane().add(getPanelSouth(), BorderLayout.SOUTH);

}

//JPanel 생성
public JPanel getPanelSouth() {
if (panelSouth  = =  null) {
panelSouth  =  new JPanel();
panelSouth.setBackground(Color.WHITE);
panelSouth.add(getBtnOk());
panelSouth.add(getBtnCancel());

}
return panelSouth;

}

//Ok 버튼 생성
public JButton getBtnOk() {
if (btnOk  = =  null) {
btnOk  =  new JButton();



btnOk.setText("확인");

}
return btnOk;

}

//Cancel 버튼 생성
public JButton getBtnCancel() {
if (btnCancel  = =  null) {
btnCancel  =  new JButton();
btnCancel.setText("취소");

}
return btnCancel;

}

```java
public static void main(String[] args) {
SwingUtilities.invokeLater(new Runnable() {
public void run() {
JPanelExample jFrame  =  new JPanelExample();
jFrame.setVisible(true);

}

});

}

}

```

실행 결과



GridLayout

열(column )

GridLayout 배치 관리자는 컨테이너를 행row과 열

column로 구성된 테이블 모양으로 구획 짓고, 각 구획

행(row )

에 하나의 컴포넌트를 배치합니다.

행과 열의 수는 GridLayout 객체를 생성할 때 생성

자의 매개값으로 주거나, 객체 생성 후 setRows ( ), setColumns ( ) 메소드로 지정할 수도 있습니다. 다

음 코드는 생성자에서 행과 열의 수를 지정하여 GridLayout을 생성한 뒤 JFrame의 배치 관리자

로 설정합니다.

jFrame.getContentPane().setLayout(new GridLayout(행수, 열수));

GridLayout을 배치 관리자로 사용하는 컨테이너가 컴포넌트를 배치할 때는 FlowLayout과 마찬

가지로 컴포넌트만 매개변수로 갖는 add ( ) 메소드를 사용합니다.

jFrame.getContentPane().add(컴포넌트);

컴포넌트 배치 순서는 첫 번째 행의 첫 번째 열부터 배치되고, 행의 마지막 열까지 배치가 끝나면 다

음 행의 첫 번째 열부터 다시 차례대로 배치됩니다.

>>> GridLayoutExample.java


```java
package sec04.exam04_gridlayout;

import java.awt.GridLayout;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.SwingUtilities;

public class GridLayoutExample extends JFrame {
private JButton[][] btn;
```

//메인 윈도우 설정





public GridLayoutExample() {
setTitle("GridLayoutExample");
setSize(300, 100);
setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

//GridLayout으로 변경하고 버튼 추가
setLayout(new GridLayout(2,3));
for(int r  =  0; r<2; r++) {
for(int c = 0; c<3; c++) {
getContentPane().add(getBtn()[r][c]);

}

}

}

//버튼 배열 생성
public JButton[][] getBtn() {
if(btn  = =  null) {
btn  =  new JButton[2][3];
for(int r  =  0; r<2; r++) {
for(int c = 0; c<3; c++) {
btn[r][c]  =  new JButton();
btn[r][c].setText("["+r+"][" + c + "]");

}

}

}
return btn;

}

```java
public static void main(String[] args) {
SwingUtilities.invokeLater(new Runnable() {
public void run() {
GridLayoutExample jFrame  =  new GridLayoutExample();
jFrame.setVisible(true);

}

});

}

}






```

실행 결과

CardLayout

CardLayout 배치 관리자는 이름에서도 알 수 있듯이 여러 장의 카드를 포개 놓고 한 번에 하나의

카드를 보여주는 역할을 합니다. 이때 카드는 하나의 JPanel로 구성됩니다.

CardLayout

컴포넌트

컴포넌트

컴포넌트

Card1 (JPanel )

Card2 (JPanel )

CardLayout이 적용된 컨테이너에 카드 하나를 추가할 때에는 카드의 이름과 JPanel을 추가할 수

있는 add ( ) 메소드를 사용합니다. 그리고 Card의 내용은 JPanel 안에 배치하면 됩니다.

jFrame.getContentPane().add("Card1", jPanel1);
jFrame.getContentPane().add("Card2", jPanel2);

여러 개의 카드를 추가하더라도 제일 먼저 추가한 카드만 보인다. 다른 카드는 아래에 겹쳐져 있어

볼 수 없는데, 이 카드를 보이게 하려면 CardLayout의 first ( ), last ( ), next ( ), show ( ) 메소드

를 호출하면 됩니다.



CardLayout 메소드

first(Container container)

last(Container container)

next(Container container)

설명

첫 번째 배치한 카드를 보이게 합니다.

마지막에 배치한 카드를 보이게 합니다.

현재 카드 다음에 배치한 카드를 보이게 합니다.

show(Container container, String name)

지정된 이름의 카드를 보이게 합니다.

메소드의 첫 번째 매개값인 Container는 CardLayout을 사용하는 컨테이너이고, show ( ) 메소드

의 두 번째 매개값은 보여줄 카드 이름입니다. 다음 예제는 3개의 색깔 카드를 JFrame에 추가하고 1초

간격으로 카드를 변경해서 보여 준다.

>>> CardLayoutExample.java

```java
package sec04.exam05_cardlayout;

import java.awt.CardLayout;
import java.awt.Color;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;

public class CardLayoutExample extends JFrame {
private JPanel redCard, greenCard, blueCard;
```

//메인 윈도우 설정
public CardLayoutExample() {
this.setTitle("CardLayoutExample");
this.setSize(250, 400);
this.setResizable(false);
this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

//CardLayout으로 변경하고 3개의 카드 추가
this.getContentPane().setLayout(new CardLayout());
this.getContentPane().add("RedCard", getRedCard());
this.getContentPane().add("GreenCard", getGreenCard());
this.getContentPane().add("BlueCard", getBlueCard());

}





//RedCard에 해당하는 JPanel 생성
public JPanel getRedCard() {
if (redCard  = =  null) {
redCard  =  new JPanel();
redCard.setBackground(Color.RED);

}
return redCard;

}

//GreenCard에 해당하는 JPanel 생성
public JPanel getGreenCard() {
if (greenCard  = =  null) {
greenCard  =  new JPanel();
greenCard.setBackground(Color.GREEN);

}
return greenCard;

}

//BlueCard에 해당하는 JPanel 생성
public JPanel getBlueCard() {
if (blueCard  = =  null) {
blueCard  =  new JPanel();
blueCard.setBackground(Color.BLUE);

}
return blueCard;

}

```java
public static void main(String[] args) {
SwingUtilities.invokeLater(new Runnable() {
public void run() {
final CardLayoutExample jFrame  =  new CardLayoutExample();
jFrame.setVisible(true);
//반복 스레드 생성
Thread thread  =  new Thread() {
@Override
public void run() {
for (int i  =  0; i < 10; i++) {
try {
//2초간 일시정지
Thread.sleep(1000);



} catch (InterruptedException e) {

}
//이벤트 큐에 Runnable 객체 넣기
SwingUtilities.invokeLater(new Runnable() {
@Override
public void run() {
//CardLayout을 얻어 다음 카드 보여주기
CardLayout cardLayout  =
(CardLayout) jFrame.getContentPane().getLayout();
cardLayout.next(jFrame.getContentPane());

}

});

}

}

};
//반복 스레드 시작
thread.start();

}

});

}

}


```

실행 결과




NullLayout

NullLayout은 컨테이너의 setLayout ( ) 메소드에 배치 관리자 대신 매개값을 null로 설정한 것을

말합니다. 이것은 어떠한 배치 관리자도 사용하지 않고 좌표값으로 컴포넌트를 배치함을 뜻합니다.

jFrame.getContentPane().setLayout(null);

컨테이너가 컴포넌트를 배치할 때 좌표값을 주는 것이 아니라, 컴포넌트쪽에서 컨테이너의 어떤 위

치에 배치될 것인지 setBounds ( ) 메소드로 좌표값을 설정해야 합니다.

setBounds(int x, int y, int width, int height);

x, y 매개값은 픽셀 단위의 좌표값인데, 컨테이너의 좌

측 상단이 (0, 0 )이고 우측이 x축, 하단이 y축입니다. x의

(0, 0 )


최대값은 컨테이너의 폭width이고, y의 최대값은 컨테이

너의 높이height입니다. width 매개값은 컴포넌트의 폭을


(100, 50 )

말하고, height 매개값은 컴포넌트의 높이를 말합니다.

y


다음 예제는 JButton을 다음 그림과 같이 배치합니다.

x


>>> NullLayoutExample.java


```java
package sec04.exam06_nulllayout;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.SwingUtilities;

public class NullLayoutExample extends JFrame {
private JButton btnOk;
```

//메인 윈도우 설정
public NullLayoutExample() {
this.setTitle("NullLayoutExample");





this.setSize(300, 200);
this.setResizable(false);
this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

//NullLayout 설정과 버튼 추가
this.getContentPane().setLayout(null);
this.getContentPane().add(getBtnOk());

}

//버튼 생성
public JButton getBtnOk() {
if(btnOk  = =  null) {
btnOk  =  new JButton();
btnOk.setText("확인");
//버튼이 위치할 좌표값과 폭과 높이 설정
btnOk.setBounds(100, 50, 70, 60);

}
return btnOk;

}

```java
public static void main(String[] args) {
SwingUtilities.invokeLater(new Runnable() {
public void run() {
NullLayoutExample jFrame  =  new NullLayoutExample();
jFrame.setVisible(true);

}

});

}

}

Pack
```

JWindow, JFrame, JDialog와 같이 java.awt.Window를 상속받는 최상위 레벨 컨테이너는

pack ( )이라는 메소드를 사용해서 내부의 컴포넌트의 크기에 맞게 컨테이너의 크기를 자동으로 조

절할 수 있습니다.

컴포넌트에는 PreferredSize라는 속성이 있는데, 이것은 컴포넌트의 기본 배치 크기를 말합니다. 컨





테이너의 pack ( ) 메소드가 호출되면 내부 컴포넌트의 getPreferredSize ( )를 호출해서 컴포넌트

의 기본 배치 크기를 알아낸 뒤, 컨테이너의 크기를 계산합니다.

컨테이너의 setSize ( ) 메소드는 직접 컨테이너의 폭과 높이를 설정하지만, pack ( ) 메소드는 내부

컴포넌트의 크기에 따라 컨테이너의 크기가 결정됩니다. 따라서 pack ( ) 메소드를 호출하는 시점은

컨테이너에 컴포넌트들이 모두 배치가 끝난 시점이어야 합니다.

다음 예제는 JFrame에 두 개의 JButton을 추가하고 pack ( ) 메소드를 호출했다. JFrame의 크기

는 두 버튼의 크기에 최대한 맞추게 됩니다.

>>> PackExample.java


```java
package sec04.exam07_pack;

import java.awt.FlowLayout;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.SwingUtilities;

public class PackExample  extends JFrame {
private JButton btnOk;
private JButton btnCancel;
```

//메인 윈도우 설정
public PackExample() {
this.setTitle("FlowLayoutExample");
this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

//FlowLayout으로 변경하고 버튼 추가
this.setLayout(new FlowLayout());
this.getContentPane().add(getBtnOk());
this.getContentPane().add(getBtnCancel());

//pack() 메소드 호출
this.pack();

}

//Ok 버튼 생성
private JButton getBtnOk() {







if(btnOk  = =  null) {
btnOk  =  new JButton();
btnOk.setText("확인");

}
return btnOk;

}

//Cancel 버튼 생성
private JButton getBtnCancel() {
if(btnCancel  = =  null) {
btnCancel  =  new JButton();
btnCancel.setText("취소");

}
return btnCancel;

}

```java
public static void main(String[] args) {
SwingUtilities.invokeLater(new Runnable() {
public void run() {
PackExample jFrame  =  new PackExample();
jFrame.setVisible(true);

}

});

}

}

```

실행 결과

