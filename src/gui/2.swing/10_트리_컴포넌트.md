# 10. 트리 컴포넌트

트리 컴포넌트는 계층적인 데이터를 표시하는 컴포넌트입니다. Swing은 트리 컴포넌트로 JTree를

제공합니다. JTree는 하나의 루트 노드root node 아래에 여러 개의 자식 노드child node를 가지며, 자식 노

드는 또 다시 자식 노드를 가질 수 있습니다.

동일한 부모 노드parent node를 갖는 노드들을 묶어서 형제 노드sibling node라고 부르는데, 다음 그림에서

친구1과 친구2는 형제 노드입니다. 자식 노드가 없는 마지막 노드는 잎사귀 노드라고 해서 리프leaf 노

드라고 부른다.



루트 노드

리프 노드

자식을 갖는 부모 노드

트리 생성

JTree 를  생성하려면  생성자의  매개값으로  루트  노드를  대입해야  하는데,  루트  노드는

DefaultMutableTreeNode로 생성합니다. DefaultMutableTreeNode는 루트 노드뿐만 아니라

부모 노드, 리프 노드를 생성하는 데 사용됩니다.

다음은 DefaultMutableTreeNode로 생성된 계층적 데이터를 JTree를 생성할 때 매개값으로 제

공해야 함을 보여 준다.

DefaultMutableTreeNode
DefaultMutableTreeNode
|-- DefaultMutableTreeNode
|-- DefaultMutableTreeNode
|-- DefaultMutableTreeNode
|-- DefaultMutableTreeNode

JTree jTree  =  new JTree(     );

노드의 표현 방법은 DefaultTreeCellRenderer가 결정합니다. DefaultTreeCellRenderer는

JLabel의 하위 클래스로서 노드를 아이콘과 텍스트로 조합해서 보여 준다. 기본적으로 루트 노드나

부모 노드는 폴더 모양의 아이콘으로 표현하고, 리프 노드는 문서 모양의 아이콘으로 표현합니다.

다음 예제는 기본적인 노드의 모양을 보여 준다.

>>> JTreeExample.java


```java
package sec10.exam01_jtree;

import java.awt.BorderLayout;
import javax.swing.JFrame;





import javax.swing.JScrollPane;
import javax.swing.JTree;
import javax.swing.SwingUtilities;
import javax.swing.tree.DefaultMutableTreeNode;

public class JTreeExample extends JFrame {
private JTree jTree;
```

//메인 윈도우 설정
public JTreeExample() {
this.setTitle("JTreeExample");
this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
this.getContentPane().add(new JScrollPane(getJTree()),
BorderLayout.CENTER);
this.setSize(200, 150);

}

//JTree 생성
public JTree getJTree() {
if (jTree  = =  null) {
DefaultMutableTreeNode root  = new DefaultMutableTreeNode("그룹리스트");

DefaultMutableTreeNode node1  =  new DefaultMutableTreeNode("친구");
node1.add(new DefaultMutableTreeNode("친구1"));
node1.add(new DefaultMutableTreeNode("친구2"));
root.add(node1);

DefaultMutableTreeNode node2  = new DefaultMutableTreeNode("회사동료");
node2.add(new DefaultMutableTreeNode("동료1"));
node2.add(new DefaultMutableTreeNode("동료2"));
root.add(node2);

jTree  =  new JTree(root);

}
return jTree;

}

```java
public static void main(String[] args) {
SwingUtilities.invokeLater(new Runnable() {
public void run() {




JTreeExample jFrame  =  new JTreeExample();
jFrame.setVisible(true);

}

});

}

}

```

실행 결과

노드 표현 변경

노드의 아이콘과 리프 노드의 표현을 다르게 변형하고 싶다면 새로운 TreeCellRenderer를 만들

어 기본 렌더러인 DefaultTreeCellRenderer를 대체하면 됩니다. 새로운 TreeCellRenderer는

TreeCellRenderer 인터페이스를 구현해서 만든다.

```java
public class MyTreeCellRenderer implements TreeCellRenderer {
public Component getTreeCellRendererComponent(...)  {
//컴포넌트를 초기화하고 리턴하는 코드

}

}
```

getTreeCellRendererComponent ( ) 메소드는 주어진 매개값을 이용해서 노드를 표현할 컴포넌

트를 리턴하는 역할을 합니다. 매개변수는 총 6개로 다음과 같은 값을 가지고 있습니다.


매개변수

tree

value

sel

expanded

leaf

hasFocus

값 또는 참조

노드을 포함하고 있는 JTree 참조

노드인 DefaultMutableTreeNode 객체

노드가 선택되었는지 여부

부모 노드가 펼쳐졌는지 여부

리프 노드인지 여부

포커스를 가지고 있는지 여부

새로운 TreeCellRenderer가 정의되었다면 JTree의 setCellRenderer ( ) 메소드로 기본 렌더러

를 변경하면 됩니다.

jTree.setCellRenderer(new MyTreeCellRenderer());

다음 예제는 부모 노드의 아이콘을 변경하고 리프 노드를 아이콘+글자+아이콘으로 표현합니다.

>>> JTreeExample.java


```java
package sec10.exam02_cellrenderer;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTree;
import javax.swing.SwingUtilities;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreeCellRenderer;

public class JTreeExample extends JFrame {





private JTree jTree;
```

//메인 윈도우 설정
public JTreeExample() {
this.setTitle("JTreeExample");
this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
this.getContentPane().add(new JScrollPane(getJTree()),
BorderLayout.CENTER);
this.setSize(200, 150);

}

//JTree 생성
public JTree getJTree() {
if (jTree  = =  null) {
DefaultMutableTreeNode root  = new DefaultMutableTreeNode("그룹리스트");

DefaultMutableTreeNode node1  =  new DefaultMutableTreeNode("친구");
node1.add(new DefaultMutableTreeNode("친구1"));
node1.add(new DefaultMutableTreeNode("친구2"));
root.add(node1);

DefaultMutableTreeNode node2  = new DefaultMutableTreeNode("회사동료");
node2.add(new DefaultMutableTreeNode("동료1"));
node2.add(new DefaultMutableTreeNode("동료2"));
root.add(node2);

jTree  =  new JTree(root);
//노드 표현 방법 변경
jTree.setCellRenderer(new MyTreeCellRenderer());

}
return jTree;

}

//TreeCellRender 정의
```java
public class MyTreeCellRenderer implements TreeCellRenderer {
public Component getTreeCellRendererComponent(
JTree tree, Object value, boolean sel, boolean expanded,
boolean leaf, int row, boolean hasFocus) {
if (!leaf) {
JLabel jLabel  =  new JLabel();








jLabel.setBorder(BorderFactory.createEmptyBorder(5, 0, 5, 0));
//노드 간 상하 간격
jLabel.setIcon(new ImageIcon(getClass().getResource("parentnode.gif")));
jLabel.setText(value.toString());
return jLabel;
} else {
JPanel jPanel  =  new JPanel();
jPanel.setBackground(Color.WHITE);
jPanel.setLayout(new BorderLayout());
jPanel.setBorder(BorderFactory.createEmptyBorder(3, 0, 3, 0));
//노드 간 상하 간격

JLabel lblWest  =  new JLabel(new ImageIcon(getClass().
getResource("logon.gif")));
JLabel lblCenter  =  new JLabel("  " + value.toString() + "  ");
JLabel lblEast  =  new JLabel(new ImageIcon(getClass().
getResource("time.gif")));
jPanel.add(lblWest, BorderLayout.WEST);
jPanel.add(lblCenter, BorderLayout.CENTER);
jPanel.add(lblEast, BorderLayout.EAST);

if (sel) {
jPanel.setBackground(Color.ORANGE); //노드 선택 시 오렌지 배경색 설정

}
return jPanel;

}

}

}

public static void main(String[] args) {
SwingUtilities.invokeLater(new Runnable() {
public void run() {
JTreeExample jFrame  =  new JTreeExample();
jFrame.setVisible(true);

}

});

}

}






```

실행 결과

이벤트 처리

JTree에서 노드 선택이 변경되면 TreeSelectionEvent가 발생하기 때문에 TreeSelectionListener

를 추가해서 이벤트를 처리할 수 있습니다. TreeSelectionListener의 valueChanged ( ) 메소드는 노

드 선택이 변경되면 호출됩니다. 다음은 TreeSelectionListener 구현 클래스를 작성하는 방법을 보

여 준다.

```java
public class MyTreeSelectionListener implements TreeSelectionListener {
public void valueChanged(TreeSelectionEvent e) {
//선택된 노드의 전체 경로 얻기
TreePath treePath  =  e.getPath();
//선택된 노드의 DefaultMutableTreeNode 얻기
DefaultMutableTreeNode node  =
(DefaultMutableTreeNode) treePath.getLastPathComponent();
//선택된 노드의 텍스트 얻기
String userObject  =  (String) node.getUserObject();
//처리 코드

//~

}

}
```

TreeSelectionEvent의 getPath ( )는 루트 노드에서부터 선택된 노드까지의 경로 정보를 가지고

있는 TreePath를 리턴합니다. TreePath의 getLastPathComponent ( )는 선택된 노드를 Object

타입으로 리턴하는데, DefaultMutableTreeNode로 타입 변환할 수 있습니다.

선택된 노드의 문자열은 DefaultMutableTreeNode의 getUserObject ( ) 메소드로 얻을 수 있



다. 만약 노드 선택 변경보다는 클릭과 더블 클릭에 더 관심이 있다면 다음과 같이 MouseEvent를

처리할 수도 있습니다.

```java
public class MyMouseListener extends MouseAdapter {
public void mousePressed(MouseEvent e) {
//JTree 얻기
JTree jTree  =  (JTree) e.getSource();
//선택된 노드의 전체 경로 얻기
TreePath treePath  =  jTree.getPathForLocation(e.getX(), e.getY());
//선택된 노드가 있을 경우
if(selRow != -1) {
if(e.getClickCount()  = =  1) {
//클릭했을 경우 실행할 코드
} else if(e.getClickCount()  = =  2) {
//더블 클릭했을 경우 실행할 코드

}

}

}

}
```

JTree의 getPathForLocation ( ) 메소드는 마우스로 클릭된 좌표를 가지고 선택된 노드의 전

체 경로를 가진 TreePath를 리턴합니다. 마우스를 클릭했느냐 더블 클릭했느냐는 MouseEvent의

getClickCount ( )의 리턴값으로 구분할 수 있으므로 if 문으로 실행할 코드를 선택할 수 있습니다.

다음 예제는 TreeSelectionListener를 추가해서 선택 노드의 텍스트를 메시지 다이얼로그로 나타

내고, MouseListener를 추가해서 마우스 더블 클릭을 처리했다.

>>> JTreeExample.java


```java
package sec10.exam03_eventhandling;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseListener;
import javax.swing.BorderFactory;





import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTree;
import javax.swing.SwingUtilities;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreeCellRenderer;
import javax.swing.tree.TreePath;

public class JTreeExample extends JFrame {
private JTree jTree;
```

//메인 윈도우 설정
public JTreeExample() {
this.setTitle("JTreeExample");
this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
this.getContentPane().add(new JScrollPane(getJTree()),
BorderLayout.CENTER);
this.setSize(200, 150);

}

//JTree 생성
public JTree getJTree() {
if (jTree  = =  null) {
DefaultMutableTreeNode root  = new DefaultMutableTreeNode("그룹리스트");

DefaultMutableTreeNode node1  =  new DefaultMutableTreeNode("친구");
node1.add(new DefaultMutableTreeNode("친구1"));
node1.add(new DefaultMutableTreeNode("친구2"));
root.add(node1);

jTree  =  new JTree(root);
jTree.setCellRenderer(new MyTreeCellRenderer());

//이벤트 리스너 추가








jTree.addTreeSelectionListener(treeSelectionListener);
jTree.addMouseListener(mouseListener);

}
return jTree;

}

//TreeSelectionListener 필드 선언
private TreeSelectionListener treeSelectionListener  =
new TreeSelectionListener() {
```java
@Override
public void valueChanged(TreeSelectionEvent e) {
TreePath treePath  =  e.getPath();
DefaultMutableTreeNode treeNode  =
(DefaultMutableTreeNode) treePath.getLastPathComponent();
String nodeText  =  (String) treeNode.getUserObject();
JOptionPane.showMessageDialog(JTreeExample.this, "노드 변경: " +
nodeText);

}

};
```

//MouseListener 필드 선언
private MouseListener mouseListener  =  new MouseAdapter() {
```java
public void mouseClicked(java.awt.event.MouseEvent e) {
//더블 클릭이 되었을 경우에만 실행
if (e.getClickCount()  = =  2) {
TreePath treePath  =  jTree.getPathForLocation(e.getX(), e.getY());
DefaultMutableTreeNode treeNode  =
(DefaultMutableTreeNode) treePath.getLastPathComponent();
String nodeText  =  (String) treeNode.getUserObject();
JOptionPane.showMessageDialog(JTreeExample.this, "더블 클릭: " +
nodeText);

}

};

};
```

//TreeCellRender 정의
```java
public class MyTreeCellRenderer implements TreeCellRenderer {
public Component getTreeCellRendererComponent(
JTree tree, Object value, boolean sel, boolean expanded,










boolean leaf, int row, boolean hasFocus) {
if (!leaf) {
JLabel jLabel  =  new JLabel();
jLabel.setBorder(BorderFactory.createEmptyBorder(5, 0, 5, 0));
jLabel.setIcon(new ImageIcon(getClass().getResource
("parentnode.gif")));
jLabel.setText(value.toString());
return jLabel;
} else {
JPanel jPanel  =  new JPanel();
jPanel.setBackground(Color.WHITE);
jPanel.setLayout(new BorderLayout());
jPanel.setBorder(BorderFactory.createEmptyBorder(3, 0, 3, 0));

JLabel lblWest  =  new JLabel(new ImageIcon(getClass().
getResource("logon.gif")));
JLabel lblCenter  =  new JLabel("  " + value.toString() + "  ");
JLabel lblEast  =  new JLabel(new ImageIcon(getClass().
getResource("time.gif")));
jPanel.add(lblWest, BorderLayout.WEST);
jPanel.add(lblCenter, BorderLayout.CENTER);
jPanel.add(lblEast, BorderLayout.EAST);

if (sel) {
jPanel.setBackground(Color.ORANGE);

}
return jPanel;

}

}

}

public static void main(String[] args) {
SwingUtilities.invokeLater(new Runnable() {
public void run() {
JTreeExample jFrame  =  new JTreeExample();
jFrame.setVisible(true);

}

});

}

}





```

실행 결과

