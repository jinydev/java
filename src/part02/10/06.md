---
layout: part02
title: "10.6 전이 의존"
nav_order: 6
parent: "Chapter 10. 라이브러리와 모듈"
grand_parent: "객체지향 자바 프로그래밍"
---

# 10.6 전이 의존

`my_application_2` 프로젝트와 `my_module_a`, `my_module_b` 모듈의 의존 관계는 다음과 같이 표현할 수 있다. `my_application_2`는 직접적으로 두 모듈을 requires 하고 있기 때문이다.

```
my_application_2 -> my_module_a
                 -> my_module_b
```

다음과 같이 의존 관계를 변경한다고 가정해 보자.

```
my_application_2 -> my_module_a -> my_module_b
```

`my_application_2`는 `my_module_a`에 의존하고, `my_module_a`는 `my_module_b`에 의존한다. 따라서 `my_application_2`와 `my_module_a`의 모듈 기술자는 다음과 같이 작성할 수 있을 것이다.

**my_application_2 module-info.java**
```java
module my_application_2 {
    requires my_module_a;
}
```

**my_module_a module-info.java**
```java
module my_module_a {
    exports pack1;
    requires my_module_b;
}
```

이렇게 작성하면 `my_application_2`의 Main 클래스는 `my_module_b` 모듈을 사용할 수 없기 때문에 컴파일 오류가 발생한다. `my_application_2`의 모듈 기술자에서 `requires my_module_b`가 빠졌기 때문이다.

Main 클래스에서 `my_module_b` 패키지 코드를 모두 제거하면 되겠지만, 제거할 수 없는 경우도 있다. 다음과 같이 `my_module_a` 소속의 A 클래스가 `my_module_b` 소속의 C 타입 객체를 리턴하는 경우이다.

```java
A a = new A();
C c = a.method();
```

`my_application_2`에서 이 코드를 사용해야 한다면 C 타입이 있기 때문에 `my_application_2`의 모듈 기술자에 `requires my_module_b`를 반드시 추가해야 한다. `my_application_2`는 단지 `my_module_a`만 사용하고 싶었는데도 말이다.

이 문제를 해결할 방법은 `my_module_a`가 가지고 있다. `my_module_a`의 모듈 기술자에 `transitive` 키워드와 함께 `my_module_b`를 의존 설정하면 된다. 그러면 `my_application_2`에서도 `my_module_b`를 사용할 수 있게 된다. 의존 설정이 전이되기 때문이다.

**my_module_a module-info.java**
```java
module my_module_a {
    exports pack1;
    requires transitive my_module_b;
}
```

다음 실습을 통해 전이 의존을 확인해 보자.

## my_module_a 모듈 수정

1.  Package Explorer 뷰에서 `my_module_a`를 선택하고 마우스 오른쪽 버튼으로 클릭하여 [Build Path] - [Configure Build Path] 메뉴를 클릭한다. [Projects] 탭에서 Modulepath 항목을 선택한 후 [Add] 버튼을 클릭한다. `my_module_b` 모듈의 체크박스에 체크하고 [OK] 버튼을 클릭한다.

2.  Required projects on the build path에 `my_module_b` 모듈이 추가된 것을 확인하고 [Apply and Close] 버튼을 클릭한다.

3.  `my_module_a`의 모듈 기술자를 열고 다음과 같이 `my_module_b` 모듈을 전이적 의존으로 기술한다.

    **module-info.java**
    ```java
    module my_module_a {
        exports pack1;
        // exports pack2;
        requires transitive my_module_b;
    }
    ```

4.  `my_module_a`의 `A` 클래스에서 `getC()` 메소드를 선언한 다음, `my_module_b` 소속의 `C` 클래스로부터 객체를 생성하고 리턴하도록 다음과 같이 작성한다.

    **A.java**
    ```java
    package pack1;

    import pack2.B;
    import pack3.C;

    public class A {
        // 메소드
        public void method() {
            System.out.println("A-method 실행");
            // B 클래스 사용
            B b = new B();
            b.method();
        }
        
        // 메소드
        public C getC() {
            C c = new C();
            return c;
        }
    }
    ```

## my_application_2 프로젝트 수정

1.  Package Explorer 뷰에서 `my_application_2` 프로젝트의 모듈 기술자를 열고, `my_module_b` 모듈의 직접적 의존 관계를 주석 처리한다.

    **module-info.java**
    ```java
    module my_application_2 {
        requires my_module_a;
        // requires my_module_b;
    }
    ```

2.  `my_application_2`의 `Main` 클래스에 다음과 같이 21~22라인을 추가한다.

    **Main.java**
    ```java
    package app;

    import pack1.A;
    // import pack2.B;
    import pack3.C;

    public class Main {
        public static void main(String[] args) {
            // my_module_a 패키지에 포함된 A 클래스 이용
            A a = new A();
            a.method();
            
            // my_module_a 패키지에 포함된 B 클래스 이용
            // B b = new B();
            // b.method();
            
            // my_module_b 패키지에 포함된 C 클래스 이용
            C c = new C();
            c.method();
            
            C result = a.getC();
            result.method();
        }
    }
    ```

    **실행 결과**
    ```
    A-method 실행
    B-method 실행
    C-method 실행
    C-method 실행
    ```

`my_application_2` 모듈 기술자에서 `requires my_module_b`를 제거했음에도 불구하고 여전히 Main 클래스에서 `my_module_b` 소속의 `pack3.C` 클래스를 사용할 수 있다. 이는 `my_module_a` 모듈 기술자에서 `transitive`로 `my_module_b`를 의존 설정했기 때문이다.
