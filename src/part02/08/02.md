---
layout: part02
title: "8.2 인터페이스와 구현 클래스 선언"
nav_order: 2
parent: "Chapter 08. 인터페이스"
grand_parent: "객체지향 자바 프로그래밍"
---

# 8.2 인터페이스와 구현 클래스 선언

인터페이스는 `*.java` 형태의 소스 파일로 작성되고 `*.class` 형태로 컴파일되기 때문에 물리적 형태는 클래스와 동일하다. 단, 소스를 작성할 때 선언하는 방법과 구성 멤버가 클래스와 다르다.

## 인터페이스 선언

인터페이스 선언은 `class` 키워드 대신 `interface` 키워드를 사용한다. 접근 제한자로는 클래스와 마찬가지로 같은 패키지 내에서만 사용 가능한 `default`, 패키지와 상관없이 사용하는 `public`을 붙일 수 있다.

```java
interface 인터페이스명 { ... } // default 접근 제한
public interface 인터페이스명 { ... } // public 접근 제한
```

중괄호 안에는 인터페이스가 가지는 멤버들을 선언할 수 있는데, 다음과 같은 종류가 있다.

```java
public interface 인터페이스명 {
    // public 상수 필드
    // public 추상 메소드
    // public 디폴트 메소드
    // public 정적 메소드
    // private 메소드
    // private 정적 메소드
}
```

각 멤버의 역할은 다음 절부터 하나씩 살펴보기로 하고, 여기서는 이클립스에서 인터페이스를 선언하는 방법을 알아보자.

1.  Package Explorer 뷰에서 `thisisjava` 프로젝트의 `src` 폴더에 `ch08.sec02` 패키지를 생성하고, 마우스 오른쪽 버튼으로 클릭하여 [New] - [Interface]를 선택한다.
2.  [New Java Interface] 대화상자가 나타나면 Name 입력란에 인터페이스명으로 `RemoteControl`을 입력하고, [Finish] 버튼을 클릭한다.
3.  그리고 다음과 같이 `public` 추상 메소드인 `turnOn()`을 하나 작성한다. 추상 메소드란 선언부만 있고 실행부인 중괄호가 없는 메소드를 말한다.

**RemoteControl.java**
```java
package ch08.sec02;

public interface RemoteControl {
	// public 추상 메소드
	public void turnOn();
}
```

## 구현 클래스 선언

다음 그림을 다시 보자. 객체 A가 인터페이스의 추상 메소드를 호출하면 인터페이스는 객체 B의 메소드를 실행한다. 그렇다면 객체 B는 인터페이스에 선언된 추상 메소드와 동일한 선언부를 가진(재정의된) 메소드를 가지고 있어야 한다.

여기서 객체 B를 인터페이스를 구현한(implement) 객체라고 한다. 인터페이스에 정의된 추상 메소드에 대한 실행 내용이 구현(작성)되어 있기 때문이다. 객체 B와 같은 구현 객체는 다음과 같이 인터페이스를 구현하고 있음을 선언부에 명시해야 한다.

```java
public class B implements 인터페이스명 { ... }
```

`implements` 키워드는 해당 클래스가 인터페이스를 통해 사용할 수 있다는 표시이며, 인터페이스의 추상 메소드를 재정의한 메소드가 있다는 뜻이다.

앞에서 선언한 `RemoteControl` 인터페이스로 `Television`을 사용할 수 있도록 `Television` 구현 클래스를 선언해 보자.

`ch08.sec02` 패키지에서 `RemoteControl`의 추상 메소드인 `turnOn()`을 다음과 같이 재정의한다.

**Television.java**
```java
package ch08.sec02;

public class Television implements RemoteControl {
	@Override
	public void turnOn() {
		System.out.println("TV를 켭니다.");
	}
}
```

또는

```java
package ch08.sec02;

public class Audio implements RemoteControl {
	@Override
	public void turnOn() {
		System.out.println("Audio를 켭니다.");
	}
}
```

## 변수 선언과 구현 객체 대입

인터페이스도 하나의 타입이므로 변수의 타입으로 사용할 수 있다. 인터페이스는 참조 타입에 속하므로 인터페이스 변수에는 객체를 참조하고 있지 않다는 뜻으로 `null`을 대입할 수 있다.

```java
RemoteControl rc;
RemoteControl rc = null;
```

인터페이스를 통해 구현 객체를 사용하려면, 인터페이스 변수에 구현 객체를 대입해야 한다. 정확히 말하면 구현 객체의 번지를 대입해야 한다. 다음은 `Television` 객체를 생성하고 번지를 대입하는 코드이다.

```java
rc = new Television();
```

만약 `Television`이 `implements RemoteControl`로 선언되지 않았다면 `RemoteControl` 타입의 변수 `rc`에 대입할 수 없다. 인터페이스 변수에 구현 객체가 대입이 되었다면 변수를 통해 인터페이스의 추상 메소드를 호출할 수 있게 된다.

```java
rc.turnOn();
```

인터페이스 변수를 통해 `turnOn()` 메소드가 호출되면, 실제로 실행되는 것은 `Television`에서 재정의된 `turnOn()` 메소드이다. 이를 확인하기 위해 다음과 같이 `RemoteControlExample`을 작성하고 실행해 보자.

**RemoteControlExample.java**
```java
package ch08.sec02;

public class RemoteControlExample {
	public static void main(String[] args) {
		RemoteControl rc;
		
		// rc 변수에 Television 객체를 대입
		rc = new Television();
		rc.turnOn();
		
		// rc 변수에 Audio 객체를 대입(교체시킴)
		rc = new Audio();
		rc.turnOn();
	}
}
```

**실행 결과**
```
TV를 켭니다.
Audio를 켭니다.
```

5~6라인처럼 변수를 먼저 선언한 다음에 구현 객체를 대입해도 되지만, 다음과 같이 변수 선언과 동시에 구현 객체를 대입할 수도 있다.

```java
RemoteControl rc = new Television();
```

`rc` 변수에는 `RemoteControl`을 구현한 어떠한 객체든 대입이 가능하다. 만약 `Audio` 객체가 구현 객체라면 다음과 같이 `Audio` 객체로 교체해서 대입할 수도 있다.

```java
rc = new Audio();
rc.turnOn();
```

이 경우, 실제 실행되는 것은 `Audio`에서 재정의된 `turnOn()` 메소드이다.
